<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>You feel drowsy.                                                 As you close your eyes,  strange shapes appear before them.    They seem familiar, yet so odd at the same time.</title>

<script type="bitsyGameData" id="exportedGameData">
You feel drowsy.                                                 As you close your eyes,  strange shapes appear before them.    They seem familiar, yet so odd at the same time.

# BITSY VERSION 6.0

! ROOM_FORMAT 1

PAL 0
NAME b&n
0,0,0
255,255,255
255,0,0

ROOM 2
0,67,68,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,69,6a,0,0,6b,6c,6d,0,6e,6f,0,0,0,0
0,0,0,0,0,0,0,6g,6h,6i,6j,6k,6l,0,0,0
0,0,0,6m,6n,6o,6p,6q,6r,6s,0,6t,0,0,0,0
0,0,0,0,6u,6v,6w,6x,6y,0,6z,70,0,0,0,0
0,71,0,0,0,0,0,72,73,0,74,75,76,77,0,0
78,79,7a,0,0,0,0,0,0,0,0,0,7b,7c,7d,7e
7f,7g,7h,0,0,0,0,0,0,0,6z,70,0,0,7i,7j
0,7k,0,0,0,0,0,0,0,0,7l,7m,7n,7o,7p,7q
0,0,0,0,0,0,0,0,0,7r,7s,0,7t,7u,0,0
0,7v,0,0,0,0,0,0,0,7w,7x,7y,7z,80,81,82
83,84,85,86,0,0,0,0,0,0,0,0,0,87,88,89
8a,8b,8c,8d,8e,0,0,0,0,0,0,0,0,0,0,0
0,0,8f,8g,8h,0,8i,0,8j,0,8k,0,0,0,0,0
0,0,0,0,0,0,0,0,0,8l,8m,8n,8o,6f,0,0
8p,8q,0,0,0,0,0,0,0,0,0,8r,8s,8t,8u,0
NAME 1
ITM 0 11,9
EXT 11,9 3 13,14
PAL 0

ROOM 3
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,8v,8w,0,0,0,0,0,0,0
0,0,0,8x,8y,8z,0,90,91,92,0,0,0,0,0,0
0,0,0,93,94,95,96,97,98,99,0,9a,9b,0,0,0
0,0,0,9c,9d,9e,9f,9g,9h,9i,9j,9k,9l,0,0,0
0,0,9m,9n,9o,9p,9q,9r,9s,9t,9u,9v,9w,0,0,0
0,0,9x,9y,9z,a0,a1,a2,a3,a4,a5,a6,a7,0,0,0
0,0,a8,a9,aa,ab,ac,ad,ae,af,ag,ah,ai,0,0,0
0,0,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,0,0
0,0,av,aw,ax,ay,az,b0,b1,b2,b3,b4,b5,au,0,0
0,0,0,b6,b7,b8,b9,ba,bb,bc,bd,be,0,0,0,0
0,0,0,b6,bf,bg,bh,bi,bj,bk,bl,0,0,0,0,0
0,0,0,0,0,8r,bm,bn,bo,bp,bq,0,0,0,0,0
0,0,0,0,0,0,br,bs,bt,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME 2
ITM 0 2,14
EXT 13,14 2 11,9
EXT 2,14 4 4,1
PAL 0

ROOM 4
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,bu
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,bv
7,7,7,5n,bw,bx,7,7,7,7,7,7,7,7,7,bv
7,7,7,by,bz,c0,c1,c2,c3,c4,c5,c6,c7,7,7,bv
7,7,7,7,7,c8,c9,ca,cb,cc,cd,ce,cf,cg,ch,bv
7,7,7,7,7,ci,cj,ck,cl,cm,cn,co,cp,cq,cr,bv
7,7,7,7,7,cs,ct,cu,cv,cw,cx,cy,cz,7,7,bv
7,7,7,7,d0,d1,d2,d3,d4,d5,d6,d7,d8,7,7,d9
7,7,7,7,da,db,dc,dd,de,df,dg,dh,di,dj,dk,dl
7,7,7,7,dm,dn,do,dp,dq,dr,ds,dt,du,dv,dw,dx
7,7,7,7,by,dy,dz,e0,e1,e2,e3,e4,e5,e6,e7,e8
7,7,7,7,e9,ea,eb,ec,ed,ee,ef,eg,eh,7,ei,ej
7,7,7,7,ek,el,em,en,eo,ep,eq,er,es,et,eu,ev
7,7,7,7,7,ew,ex,ey,ez,f0,f1,f2,f3,f4,7,bv
7,7,7,7,7,7,f5,f6,7,f7,f8,7,7,7,7,bv
f9,fa,fa,fa,fa,fb,fc,fa,fa,fd,fe,fa,fa,fa,fa,ff
NAME 3
ITM 0 10,9
EXT 4,1 3 2,14
EXT 10,9 5 3,1
PAL 0

ROOM 5
fg,fh,fi,fj,fk,fl,fm,fn,fo,fp,fq,fr,0,0,fs,ft
fu,fv,fw,0,0,0,fx,fy,fz,g0,g1,g2,g3,g4,g5,g6
g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,0,gh,gi,gj,gk,gl
gm,gn,go,gp,gq,gr,gs,gt,gu,gv,gw,gx,gy,gz,h0,h1
h2,h3,h4,h5,h6,h7,h8,h9,ha,hb,hc,hd,0,he,hf,hg
hh,hi,hj,hk,hl,hm,h8,hn,ho,hp,hq,hr,hs,ht,hu,hv
hw,hx,hy,hz,i0,i1,i2,0,i3,i4,i5,i6,i7,i8,i9,0
ia,ib,ic,id,ie,if,ig,ih,0,ii,ij,ik,il,im,in,io
ip,iq,ir,is,it,iu,iv,iw,ix,iy,iz,j0,j1,j2,j3,j4
j5,j6,j7,j8,j9,ja,0,j5,jb,jc,jd,je,jf,jg,jh,ji
0,0,0,0,jj,jk,0,0,jl,jm,jn,jo,jp,jq,jr,js
0,i1,i2,0,jt,ju,jv,jw,jx,jy,jz,k0,k1,k2,k3,k4
k5,k6,k7,0,k8,k9,ka,kb,kc,0,kd,ke,kf,kg,kh,ki
kj,kk,7a,0,0,kl,km,kn,ko,kp,0,kq,kr,ks,kt,ku
if,k7,kv,kw,kx,ky,kz,l0,l1,l2,l3,l4,l5,l6,l7,l8
l9,la,lb,lc,ld,le,lf,lg,lh,li,lj,lk,ll,lm,ln,lo
NAME 4
ITM 0 2,10
EXT 3,1 4 10,9
EXT 2,10 6 5,6
PAL 0

ROOM 6
0,0,0,0,lp,lq,lr,6a,0,0,0,0,ls,0,0,0
lt,0,0,lu,lv,8u,lw,0,0,0,lx,0,ly,0,lz,6u
m0,0,0,0,0,0,0,0,m1,m2,0,0,0,7c,0,0
6u,8a,lw,0,m3,m4,0,0,m5,0,m6,m3,0,0,0,m7
0,0,m3,0,0,0,0,m8,m9,0,ma,mb,0,mc,mc,md
0,m1,6u,m7,m4,me,mf,mg,0,6a,0,0,mh,mi,mj,mk
0,7d,lq,ml,8a,0,0,0,0,mm,0,0,mn,mm,mo,0
mb,0,m5,mp,me,mq,mr,0,0,0,0,0,0,ms,mt,0
mu,mv,0,mw,mx,my,0,8a,mz,n0,0,n1,0,0,n2,0
0,mx,n3,me,n4,n5,n6,n7,n8,n9,0,0,na,nb,7c,8h
6t,nc,0,0,0,0,0,nd,0,0,mx,0,0,0,0,ne
nf,ng,8u,nh,0,nh,0,0,0,0,ni,0,0,m7,0,nj
0,0,nk,nl,0,0,mx,ls,nm,0,m7,0,0,0,0,nn
0,lz,no,np,nq,0,nr,ns,mw,nt,0,0,m1,0,nu,nv
nw,nx,0,nh,ny,nz,6u,o0,o1,m3,0,o2,7y,o3,o4,o5
o6,o7,0,m6,o8,o9,mw,0,oa,md,0,mw,ob,0,0,nm
NAME 5
ITM 0 8,12
EXT 5,6 5 2,10
EXT 8,12 7 1,3
PAL 0

ROOM 7
oc,od,oe,of,og,oh,oi,oj,ok,ol,om,on,oo,op,oq,0
or,os,ot,ou,ov,ow,ox,oy,oz,p0,p1,p2,p3,p4,p5,p6
p7,0,p8,p9,pa,pb,pc,pd,pe,pf,pg,ph,pi,pj,pk,pl
pm,la,0,pn,po,pp,pq,pr,ps,pt,pu,0,0,pv,pw,px
py,pz,q0,q1,q2,6g,q3,q4,q5,q6,q7,q8,q9,qa,qb,qc
qd,qe,qf,qg,qh,qi,0,qj,qk,ql,qm,qn,qo,qp,qq,qr
qs,qt,qu,qv,qw,qx,qy,qz,r0,r1,r2,r3,r4,r5,r6,r7
r8,r9,ra,rb,rc,rd,re,rf,rg,rh,ri,rj,rk,rl,rm,rn
ro,rp,rq,rr,rs,rt,ru,rv,rw,rx,ry,rz,s0,s1,s2,s3
s4,s5,s6,s7,s8,s9,sa,sb,sc,sd,se,sf,sg,sh,si,sj
sk,sl,q0,sm,sn,so,sp,sq,sr,ss,st,su,sv,sw,sx,sy
sz,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc,td,te
tf,tg,th,ti,tj,tk,tl,tm,tn,to,tp,tq,tr,ts,tt,tu
tv,tw,tx,ty,p8,tz,u0,u1,u2,u3,u4,u5,u6,u7,u8,u9
ua,ub,uc,ud,ue,uf,ug,uh,ui,uj,0,uk,ul,um,un,uo
0,up,uq,0,ur,us,ut,uu,uv,uw,0,0,ux,uy,uz,v0
NAME 6
ITM 0 11,3
EXT 1,3 6 8,12
EXT 11,3 8 1,12
PAL 0

ROOM 8
v1,0,0,md,0,na,0,bo,0,8h,0,m2,0,0,nh,0
m0,0,6t,md,0,0,8u,0,0,m2,0,0,0,0,0,0
7z,m1,v2,0,o8,v3,v4,8h,0,0,0,0,v5,0,0,0
mx,0,0,0,0,v6,0,mq,0,0,0,mu,m0,v7,nh,8a
v8,8a,0,0,m5,0,v9,va,0,nh,vb,mq,0,0,0,0
0,0,6m,0,6u,mx,vc,vd,0,md,0,ve,8u,0,0,0
na,0,vf,vg,0,vh,mw,8j,0,0,0,m4,lz,m3,0,vi
0,0,vj,na,m5,0,o3,v2,0,vb,0,0,0,mp,0,0
vk,0,0,vg,me,0,vl,vm,0,0,vn,nm,0,0,vo,vp
vq,vr,0,0,0,mm,vs,vt,0,m2,ls,nt,o8,v2,0,0
vu,0,6u,vv,6a,vw,vx,0,0,o2,0,8a,vy,vz,w0,w1
w2,0,n3,0,0,0,0,w3,w4,0,m6,0,0,w5,w6,0
w7,0,0,o8,w8,0,mw,w9,wa,8a,v2,0,0,0,mu,m1
wb,0,0,0,0,m2,lr,mw,7z,v2,v8,0,6u,wc,wd,0
mc,we,wf,8j,wg,0,wh,0,wi,0,0,0,0,wj,lr,m2
0,0,m5,8h,nm,0,wk,0,0,0,8h,0,0,0,0,0
NAME 7
ITM 0 13,12
EXT 1,12 7 11,3
EXT 13,12 9 2,2
PAL 0

ROOM 9
yd,ye,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yf,yg,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yh,yi,0,0,0,0,0,0,0,0,0,0,0,0,0,0
yj,yk,yl,ym,0,0,0,0,0,0,0,0,0,0,0,0
yn,yo,yp,yq,0,0,0,0,0,0,0,0,0,0,0,0
19,yr,ys,yt,yu,ls,0,0,0,0,0,0,0,0,0,0
0,yv,yw,yx,yy,yz,0,0,0,0,0,0,0,0,0,0
0,0,z0,z1,z2,z3,0,0,0,0,0,0,0,0,0,0
0,0,z4,z5,z6,z7,z8,0,0,0,0,0,0,0,0,0
0,0,0,nf,z9,za,zb,zc,0,0,0,0,0,0,0,0
0,0,0,0,0,zd,ze,zf,zg,0,0,0,0,0,0,0
0,0,0,0,0,zh,zi,zj,zk,0,0,0,0,0,0,0
0,0,0,0,0,0,6u,zl,zm,zn,zo,0,0,0,0,0
0,0,0,0,0,0,0,zp,zq,zr,zs,0,0,0,0,0
0,0,0,0,0,0,0,0,zt,zu,zv,ym,0,0,0,0
0,0,0,0,0,0,0,0,zw,zx,zy,zz,0,0,0,0
NAME 8
ITM 0 12,14
EXT 2,2 8 13,12
END 1 12,14
PAL 0

TIL 1
01111000
01111000
11111000
11111000
11111000
11111000
11111000
01111100
NAME 0 1

TIL 2
00000111
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME 0 2

TIL 3
11110000
11110000
11111100
11111000
11111000
11111100
11111000
11111000
NAME 0 3

TIL 4
00001111
00011111
00001111
00001111
00001111
00001111
00001111
00001111
NAME 0 4

TIL 5
11100000
11100000
11100000
11100000
11100000
11100000
11100000
11100000
NAME 0 5

TIL 6
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME 0 6

TIL 7
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 7

TIL 8
00000001
00000010
10000110
11000100
11001000
11010000
10000000
00100000
NAME 0 8

TIL 9
00000111
00001111
00001111
00011111
00111111
01111111
01111111
11111111
NAME 0 9

TIL 10
10001111
10001111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 35

TIL 11
01111110
01111111
01111111
01111110
01111110
01111110
01111110
01111110
NAME 0 36

TIL 12
00000001
00000001
00000011
00000011
00000001
00000001
00000001
00000001
NAME 0 37

TIL 13
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME 0 38

TIL 14
11110000
11110000
11111000
11111000
11111000
11111000
11110000
11110000
NAME 0 39

TIL 15
00000000
00000000
00000100
00011000
00110000
01100000
01000000
00000000
NAME 0 40

TIL 16
00000000
00000000
00000000
00000000
00000001
00000111
00001111
00111111
NAME 0 41

TIL 17
01111111
01111111
01111111
01111111
11110111
11100111
11101111
11111111
NAME 0 42

TIL 18
01111110
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME 0 43

TIL 19
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME 0 44

TIL 20
00011111
00011111
00111111
00011111
00011111
00111111
00111111
00111111
NAME 0 71

TIL 21
10000000
10000001
00000011
10000111
10001111
10111111
00111111
01111111
NAME 0 72

TIL 22
11011111
10011111
10011111
00011111
00001111
00000001
10000000
11000000
NAME 0 73

TIL 23
11110000
11110000
11100000
11000000
11000001
10000001
00000011
00000011
NAME 0 74

TIL 24
00111111
00111111
01111111
11111111
01111111
01111111
00111111
01101111
NAME 0 75

TIL 25
11000000
11100000
11110000
11111000
11111000
11111100
11111110
11111110
NAME 0 76

TIL 26
00000000
00000000
00000000
00000000
00000001
00000001
00000011
00000111
NAME 0 77

TIL 27
00011111
00111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME 0 78

TIL 28
00000001
10000001
10000001
10000011
10000011
10000011
10000011
00000111
NAME 0 79

TIL 29
00001111
00011111
00111111
00111111
01111111
11111111
11111111
11111111
NAME 0 80

TIL 30
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11100001
NAME 0 107

TIL 31
11100001
11101101
11101111
11100110
11111100
11111111
11111100
11000010
NAME 0 108

TIL 32
11000010
11000011
11100001
10100001
10011111
11111111
10011111
10110011
NAME 0 109

TIL 33
10110011
11111011
11011011
11000011
11111111
11111111
11111111
11111111
NAME 0 110

TIL 34
11111011
11111001
11111111
11111111
11111111
10010000
10010000
10111000
NAME 0 111

TIL 35
11111000
10101000
00100111
11111111
00100111
10101100
11111110
01110110
NAME 0 112

TIL 36
01110110
01110000
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 113

TIL 37
11111111
11111111
11111111
11111110
11111110
11111110
11111110
11111111
NAME 0 114

TIL 38
11111111
11111111
11111111
00011100
11011100
11111110
01101010
11001001
NAME 0 115

TIL 39
11001001
11111111
11001001
00101011
00111111
00011101
00011100
11111111
NAME 0 116

TIL 40
11001001
00101011
00111111
00011101
00011100
11111111
11111111
11111111
NAME 0 143

TIL 41
11111111
00111111
10111111
10111111
00111111
11111111
11111111
11111111
NAME 0 144

TIL 42
11111111
11111111
11111111
11111111
11111111
11111111
10000111
10110111
NAME 0 145

TIL 43
10110111
10111111
10011010
11110010
11111111
11110010
00001010
00001111
NAME 0 146

TIL 44
00001111
10000111
10000111
01111111
11111111
01111111
11001111
11101111
NAME 0 147

TIL 45
11101111
01101111
00001111
11111111
11111111
11111111
11111111
11111111
NAME 0 148

TIL 46
11111111
11111111
11111111
11111111
11100001
11101101
11101111
11100110
NAME 0 149

TIL 47
11100110
11111100
11111111
11111100
11000010
11000011
11100001
10100001
NAME 0 150

TIL 48
10100001
10011111
11111111
10011111
10110011
11111011
11011011
11000011
NAME 0 151

TIL 49
11000011
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 152

TIL 50
11111111
10011111
10110011
11111011
11011011
11000011
11111111
11111111
NAME 0 179

TIL 51
11111000
11111011
11111011
11111001
11111111
11111111
11111111
01110000
NAME 0 180

TIL 52
01110000
01110000
11111000
10101000
00100111
11111111
00100111
10101100
NAME 0 181

TIL 53
10101100
11111110
01110110
01110000
11111111
11111111
11111111
11111111
NAME 0 182

TIL 54
11111111
11111111
11111111
11111111
11111111
00011001
11011000
11111111
NAME 0 183

TIL 55
10011101
10011100
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 184

TIL 56
10111111
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 185

TIL 57
11110010
11111111
11110010
00001010
00001111
10000111
10000111
01111111
NAME 0 186

TIL 58
01111111
11111111
01111111
11001111
11101111
01101111
00001111
11111111
NAME 0 187

TIL 59
11111100
11000010
11000011
11100001
10100001
10011111
11111111
10011111
NAME 0 188

TIL 60
11111000
10101000
00100111
11111111
00100111
10101100
00000100
11111101
NAME 0 215

TIL 61
11001001
11111111
11001001
01101011
11111111
11011101
00011100
11111111
NAME 0 216

TIL 62
11111111
10000111
10110111
10111111
10011010
10010101
10000000
11000101
NAME 0 217

TIL 63
11110010
00001010
00001111
10000111
10000111
01001111
00001111
00011111
NAME 0 218

TIL 64
11101101
11101111
11100110
11111100
11111111
11100100
11100110
11110100
NAME 0 219

TIL 65
11000011
11100001
10100001
10011111
11111111
10010011
10110011
00010111
NAME 0 220

TIL 66
11111011
11011011
11000011
11111111
11110001
11110110
11110100
11111000
NAME 0 221

TIL 67
00000000
01000111
11000001
11110111
10110111
01000000
01111010
01000111
NAME 1 1

TIL 68
00000000
00110000
11101000
11110100
10111010
11111010
11110100
01101000
NAME 1 2

TIL 69
10010000
01100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 3

TIL 70
00000000
00000000
00000000
00000000
00000000
00000000
10000000
01000000
NAME 1 30

TIL 71
00000000
00000000
00000000
00000000
00000000
00000000
00011000
00100100
NAME 1 31

TIL 72
00000100
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 32

TIL 73
00100000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 33

TIL 74
10010111
00101100
00100110
00110111
00010011
00011100
00000011
00000000
NAME 1 34

TIL 75
10100000
11010000
11010000
10100000
01000000
10000000
00000000
00000000
NAME 1 35

TIL 76
00001100
00010010
00101101
00111010
00111011
00111011
00101011
00010110
NAME 1 36

TIL 77
00000000
00000000
00000000
10000000
10000000
10000000
10100000
10000000
NAME 1 37

TIL 78
00010001
00000010
00000010
00000010
00000010
00000111
00001001
00010110
NAME 1 38

TIL 79
11000010
10010001
00001100
01000100
11000100
00111001
10000010
11101100
NAME 1 39

TIL 80
00000000
00000000
00000000
00001100
00010010
00100001
01001000
01000100
NAME 1 66

TIL 81
00000000
00000000
00000000
00001000
00101010
11000011
10111100
01101100
NAME 1 67

TIL 82
00000000
00000000
00000000
00000000
00000001
00000000
10000000
01000000
NAME 1 68

TIL 83
00000000
00000000
00000001
00000001
00000001
00000001
00000001
00000000
NAME 1 69

TIL 84
01001000
10110100
01011100
11011100
11011100
11010100
01101000
10010000
NAME 1 70

TIL 85
00000000
00000000
00001111
00010100
00110100
01001001
10001011
10101101
NAME 1 71

TIL 86
00000000
00000000
00000000
10000000
01000000
10100000
10100000
01000000
NAME 1 72

TIL 87
00100010
00010000
00001001
00000110
00000000
00000000
00000000
00000000
NAME 1 73

TIL 88
11111100
11011110
00101110
00011111
00000000
00000000
00000000
00000000
NAME 1 74

TIL 89
01000000
01000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME 1 75

TIL 90
00100000
00010001
00100000
01010101
10001010
11010001
11100000
00000000
NAME 2 6

TIL 91
10000000
00000000
10000000
01000000
00100000
00010000
10001000
01000101
NAME 2 7

TIL 92
00000000
00000000
00000000
00000000
00000000
01110000
10110000
00010000
NAME 2 8

TIL 93
00000011
00000010
00000001
00000000
00000000
00000000
00000001
00000010
NAME 2 9

TIL 94
01001111
00100110
01000110
10000110
01001111
10000110
01000110
00100110
NAME 2 10

TIL 95
00101100
01000100
00101000
00010000
00100000
00010000
00101000
01000100
NAME 2 11

TIL 96
00000000
00000001
00000001
00000001
00000000
00000000
00000000
00000011
NAME 2 12

TIL 97
00000000
11000001
10100010
00010100
10101010
01000001
00100001
00000001
NAME 2 13

TIL 98
00101010
11010000
11001000
01010000
10101010
01000101
11101011
00110101
NAME 2 14

TIL 99
10100000
01000000
10000000
01000000
10100000
00010000
00110000
11110000
NAME 2 15

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111

TIL b
00000000
11111101
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 10

TIL c
11111111
00011111
11100111
11111111
11111111
11111111
11111111
11111111
NAME 0 11

TIL d
11111111
11111111
11111111
11111111
11111111
11110000
11110000
11111111
NAME 0 12

TIL e
11111100
11111100
11111100
11111100
11111100
11111100
11111110
11111110
NAME 0 13

TIL f
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME 0 14

TIL g
11111000
11111000
11111100
11111100
11111100
11111000
11111000
11111100
NAME 0 15

TIL h
11110000
11110000
11110000
11110000
11110000
11110000
11110000
11110000
NAME 0 16

TIL i
11111110
11111110
11111100
11111101
11111001
11100010
10100000
11000100
NAME 0 17

TIL j
01000001
01000001
10000011
10000011
00000111
00000111
00001111
00001111
NAME 0 18

TIL k
11111110
11111110
11111110
11111000
11111000
11111001
11110000
11100000
NAME 0 19

TIL l
01111111
11111111
11111111
11111111
11111111
11111011
11111111
11111111
NAME 0 20

TIL m
11111110
11111110
11111110
11111110
11111110
01111110
11111110
11111110
NAME 0 21

TIL n
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111100
NAME 0 22

TIL o
00001111
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME 0 23

TIL p
11111111
11111111
11111111
11111111
11111110
11111100
11111000
11110001
NAME 0 24

TIL q
11001100
10001000
10011000
00110000
01100000
01000000
11000000
10000000
NAME 0 25

TIL r
00011111
00011111
00111111
00111111
01111111
01111111
11111111
11111111
NAME 0 26

TIL s
11000000
11000000
11000000
01000000
11000000
11000001
11000011
11000111
NAME 0 27

TIL t
11110111
00100011
00000011
00000011
01000011
00000011
10000111
10001111
NAME 0 28

TIL u
01111110
11111110
11111110
01111110
01111110
01111110
01111110
01111110
NAME 0 29

TIL v
00000011
00000011
00000001
00000001
00000011
00000011
00000001
00000001
NAME 0 30

TIL w
11111100
11111100
11111100
11111110
11111110
11111100
11111110
11111110
NAME 0 31

TIL x
11110000
11110000
11110000
11110000
11111000
11111000
11111000
11110000
NAME 0 32

TIL y
01110001
01000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME 0 33

TIL z
00000001
00000011
00000011
00000111
00001111
00001111
00011111
00111111
NAME 0 34

TIL 1a
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111111
NAME 0 45

TIL 1b
00001111
00000111
00001111
00001011
00000111
00011111
00111111
11111111
NAME 0 46

TIL 1c
11111000
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 47

TIL 1d
00000000
00000000
11100000
11111111
11111111
11111111
11111111
11111111
NAME 0 48

TIL 1e
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 49

TIL 1f
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00111111
NAME 0 50

TIL 1g
11111111
11111111
11111111
11111111
11111111
11111110
11111111
11111111
NAME 0 51

TIL 1h
00000001
00000111
00001111
00011111
00111111
11111111
11111111
11111111
NAME 0 52

TIL 1i
11111111
11111111
11111111
10111111
11000111
11111000
11111111
11111111
NAME 0 53

TIL 1j
11111111
11111111
11111111
11111111
11001111
00000011
00000001
11100000
NAME 0 54

TIL 1k
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011111
NAME 0 55

TIL 1l
00000000
00000000
10000000
00000000
00000000
00000000
00000000
10000000
NAME 0 56

TIL 1m
00000001
00000001
00000001
00000001
00000001
00000000
00000000
00000001
NAME 0 57

TIL 1n
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME 0 58

TIL 1o
11111111
11111111
11001001
11000000
11000000
11000000
11011000
11001000
NAME 0 59

TIL 1p
11111111
11111111
11111111
01111111
00011111
00011111
00001111
00001111
NAME 0 60

TIL 1q
11111000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 61

TIL 1r
01101111
00011111
11100000
11111000
11111110
11111110
11111111
11111111
NAME 0 62

TIL 1s
11111111
11111111
11111111
01111111
00111111
00000111
00000000
00000000
NAME 0 63

TIL 1t
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00011111
NAME 0 64

TIL 1u
10000000
00000000
00000000
10000000
00000000
00000000
10000000
10000000
NAME 0 65

TIL 1v
00000011
00000111
00001111
00001111
00011111
00111111
01111111
11111111
NAME 0 66

TIL 1w
11000000
11100000
11110000
11111000
11111111
11111111
11111111
11111111
NAME 0 67

TIL 1x
00001111
00001111
00001111
00111111
11011111
11111111
11111111
11111111
NAME 0 68

TIL 1y
11111111
11111111
11111111
11111111
11111110
11111100
11111111
11111111
NAME 0 69

TIL 1z
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11111000
NAME 0 70

TIL 2a
00000111
00001111
10001110
10011100
10111110
10111110
11111110
11111110
NAME 0 81

TIL 2b
11111111
11111110
11111100
11111110
11111110
11111100
11111110
11111110
NAME 0 82

TIL 2c
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111000
NAME 0 83

TIL 2d
11111111
11111011
11111011
11111001
11111111
11111111
11111111
01110000
NAME 0 84

TIL 2e
11111111
01110110
11111110
10101100
00100111
11111111
00100111
10101100
NAME 0 85

TIL 2f
11111111
11111111
11111111
11111111
11111111
11111110
11111110
11111110
NAME 0 86

TIL 2g
11111111
11111110
11111110
11111111
11111111
00011100
11011100
11111110
NAME 0 87

TIL 2h
11111111
01111111
01000001
11111111
11001001
00101011
00111111
00011101
NAME 0 88

TIL 2i
11111111
00111111
00111111
11111111
11111111
00111111
10111111
10111111
NAME 0 89

TIL 2j
11111111
11111111
11111111
10000111
10110111
10111111
10011010
11110010
NAME 0 90

TIL 2k
11111111
10110111
11100000
01110000
00110000
10000111
10000111
01111111
NAME 0 91

TIL 2l
11111111
01101111
00111111
01111111
00111111
01101111
00001111
11111111
NAME 0 92

TIL 2m
11111111
11100001
11101101
11101111
11100110
11111100
11111111
11111100
NAME 0 93

TIL 2n
11111111
11000011
11011011
11111011
10110011
10011111
11111111
10011111
NAME 0 94

TIL 2o
11111111
11111111
11111111
11111111
11111111
11111111
11111000
11111011
NAME 0 95

TIL 2p
11111011
11111011
11111001
11111111
11111111
11111111
01110000
01110000
NAME 0 96

TIL 2q
01110000
11111000
10101000
00100111
11111111
00100111
10101100
11111110
NAME 0 97

TIL 2r
11111110
01110110
01110000
11111111
11111111
11111111
11111111
11111111
NAME 0 98

TIL 2s
11111111
11111111
11111111
11111111
11111110
11111110
11111110
11111110
NAME 0 99

TIL 2t
11111110
11111111
11111111
11111111
00011100
11011100
11111110
01101010
NAME 0 100

TIL 2u
01101010
11001001
11111111
11001001
00101011
00111111
00011101
00011100
NAME 0 101

TIL 2v
00011100
11111111
11111111
11111111
00111111
10111111
10111111
00111111
NAME 0 102

TIL 2w
00111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 103

TIL 2x
11111111
11111111
10000111
10110111
10111111
10011010
11110010
11111111
NAME 0 104

TIL 2y
11111111
11110010
00001010
00001111
10000111
10000111
01111111
11111111
NAME 0 105

TIL 2z
11111111
01111111
11001111
11101111
01101111
00001111
11111111
11111111
NAME 0 106

TIL 3a
11111111
11111111
11111111
00111111
10111111
10111111
00111111
11111111
NAME 0 117

TIL 3b
11111111
10000111
10110111
10111111
10011010
11110010
11111111
11110010
NAME 0 118

TIL 3c
11110010
00001010
00001111
10000111
10000111
01111111
11111111
01111111
NAME 0 119

TIL 3d
01111111
11001111
11101111
01101111
00001111
11111111
11111111
11111111
NAME 0 120

TIL 3e
11111111
11111111
11111111
11111111
11111111
11111111
11100001
11101101
NAME 0 121

TIL 3f
11101101
11101111
11100110
11111100
11111111
11111100
11000010
11000011
NAME 0 122

TIL 3g
11000011
11100001
10100001
10011111
11111111
10011111
10110011
11111011
NAME 0 123

TIL 3h
11111011
11011011
11000011
11111111
11111111
11111111
11111111
11111111
NAME 0 124

TIL 3i
10111000
11000111
11001111
11000111
10111100
10111110
10010110
10010000
NAME 0 125

TIL 3j
01110000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 126

TIL 3k
11111111
11111111
11111110
11111110
11111110
11111110
11111111
11111111
NAME 0 127

TIL 3l
11111111
11111111
00011100
11011100
11111110
01101010
11001001
11111111
NAME 0 128

TIL 3m
11111111
11001001
00101011
00111111
00011101
00011100
11111111
11111111
NAME 0 129

TIL 3n
11111111
11111111
00111111
10111111
10111111
00111111
11111111
11111111
NAME 0 130

TIL 3o
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10000111
NAME 0 131

TIL 3p
10000111
10110111
10111111
10011010
11110010
11111111
11110010
00001010
NAME 0 132

TIL 3q
00001010
00001111
10000111
10000111
01111111
11111111
01111111
11001111
NAME 0 133

TIL 3r
11001111
11101111
01101111
00001111
11111111
11111111
11111111
11111111
NAME 0 134

TIL 3s
11111111
11111111
11111111
11111111
11111111
11100001
11101101
11101111
NAME 0 135

TIL 3t
11101111
11100110
11111100
11111111
11111100
11000010
11000011
11100001
NAME 0 136

TIL 3u
11100001
10100001
10011111
11111111
10011111
10110011
11111011
11011011
NAME 0 137

TIL 3v
11011011
11000011
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 138

TIL 3w
11111111
11111111
11111111
11111000
11111011
11111011
11111001
11111111
NAME 0 139

TIL 3x
11111111
11111111
11111111
01110001
01110110
11111110
10101101
00100111
NAME 0 140

TIL 3y
11111111
11111110
11111110
11111110
11111110
11111111
11111111
11111111
NAME 0 141

TIL 3z
11111111
00011100
11011100
11111110
01101010
11001001
11111111
11001001
NAME 0 142

TIL 4a
11111111
11111111
11111000
11111011
11111011
11111001
11111111
11111111
NAME 0 153

TIL 4b
11111111
11111111
01110000
01110000
11111000
10101000
00100111
11111111
NAME 0 154

TIL 4c
11111111
00100111
10101101
11111110
01110110
01110001
11111111
11111111
NAME 0 155

TIL 4d
11111110
11111110
11111110
11111110
11111111
11111111
11111111
10011100
NAME 0 156

TIL 4e
00011100
11011100
11111110
01101010
11001001
11111111
11001001
00101011
NAME 0 157

TIL 4f
00101011
00111111
00011101
00011100
11111111
11111111
11111111
00111111
NAME 0 158

TIL 4g
00111111
10111111
10111111
00111111
11111111
11111111
11111111
11111111
NAME 0 159

TIL 4h
11111111
11111111
11111111
11111111
11111111
10000111
10110111
10111111
NAME 0 160

TIL 4i
10111111
10011010
11110010
11111111
11110010
00001010
00001111
10000111
NAME 0 161

TIL 4j
10000111
10000111
01111111
11111111
01111111
11001111
11101111
01101111
NAME 0 162

TIL 4k
01101111
00001111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 163

TIL 4l
11111111
11111111
11111111
11100001
11101101
11101111
11100110
11111100
NAME 0 164

TIL 4m
11111100
11111111
11111100
11000010
11000011
11100001
10100001
10011111
NAME 0 165

TIL 4n
10011111
11111111
10011111
10110011
11111011
11011011
11000011
11111111
NAME 0 166

TIL 4o
11111111
11111000
11111011
11111011
11111001
11111111
11111111
11111111
NAME 0 167

TIL 4p
11111111
01110000
01110000
11111000
10101000
00100111
11111111
00100111
NAME 0 168

TIL 4q
00100111
10101100
11111110
01110110
01110000
11111111
11111111
11111111
NAME 0 169

TIL 4r
10011100
10111110
10101010
11001001
11111111
11001001
10101011
10111111
NAME 0 170

TIL 4s
00111111
00011101
00011100
11111111
11111111
11111111
00111111
10111111
NAME 0 171

TIL 4t
10111111
10111111
00111111
11111111
11111111
11111111
11111111
11111111
NAME 0 172

TIL 4u
11111111
11111111
11111111
11111111
10000111
10110111
10111111
10011010
NAME 0 173

TIL 4v
10011010
11110010
11111111
11110010
00001010
00001111
10000111
10000111
NAME 0 174

TIL 4w
10000111
01111111
11111111
01111111
11001111
11101111
01101111
00001111
NAME 0 175

TIL 4x
00001111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 0 176

TIL 4y
11111111
11111111
11100001
11101101
11101111
11100110
11111100
11111111
NAME 0 177

TIL 4z
11111111
11111100
11000010
11000011
11100001
10100001
10011111
11111111
NAME 0 178

TIL 5a
10011111
10110011
11111011
11011011
11000011
11111111
11111111
11111111
NAME 0 189

TIL 5b
01101010
11001000
11111110
11001000
00101010
00111111
00011000
00011001
NAME 0 190

TIL 5c
11111111
11111111
11111111
11111111
11111111
11111000
11111011
11111011
NAME 0 191

TIL 5d
11111011
11111001
11111111
11111111
11111111
01110000
01110000
11111000
NAME 0 192

TIL 5e
11111111
11111111
11111111
11111111
11111000
11111011
11111011
11111001
NAME 0 193

TIL 5f
11111001
11111111
11111111
11111111
01110000
01110000
11111000
10101000
NAME 0 194

TIL 5g
10101000
00100111
11111111
00100111
10101100
11111110
01110110
01110000
NAME 0 195

TIL 5h
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10000001
NAME 0 196

TIL 5i
10011010
10111111
10110111
10000111
11111111
11111111
11111111
11111111
NAME 0 197

TIL 5j
11111111
11111111
11111111
01110000
01110000
11111000
10101000
00100111
NAME 0 198

TIL 5k
00100111
11111111
00100111
10101100
11111110
01110110
01110000
11111111
NAME 0 199

TIL 5l
10110000
10111100
10011000
11110101
11111000
11110101
00001000
00001100
NAME 0 200

TIL 5m
11111111
00100111
10101100
11111110
01110110
01110000
11111111
11111111
NAME 0 201

TIL 5n
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME 0 202

TIL 5o
11111110
11111110
11111110
11111110
11111111
11111111
11111111
00011100
NAME 0 203

TIL 5p
10000000
10000001
01111111
11111111
01111111
11001111
11101111
01101111
NAME 0 204

TIL 5q
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111110
NAME 0 205

TIL 5r
11111110
11111110
11111110
11111111
11111111
11111111
00011100
11011100
NAME 0 206

TIL 5s
11011100
11111110
01101010
11001001
11111111
11001001
00101011
00111111
NAME 0 207

TIL 5t
11111111
11111100
10000010
10100011
11000001
11100001
10001111
11111111
NAME 0 208

TIL 5u
11111110
11111110
11111111
11111111
11111111
00011100
11011100
11111110
NAME 0 209

TIL 5v
11111110
01101010
11001001
11111111
11001001
00101011
00111111
00011101
NAME 0 210

TIL 5w
00011101
00011100
11111111
11111111
11111111
00111111
10111111
10111111
NAME 0 211

TIL 5x
10001111
11100011
11011011
10111011
10000011
11111111
11111111
11111111
NAME 0 212

TIL 5y
11000011
11011011
11111011
10110011
10011111
11111111
10011111
10110011
NAME 0 213

TIL 5z
11111011
11111001
11111111
11111111
11111111
11111001
11111001
11111101
NAME 0 214

TIL 6a
00010000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 4

TIL 6b
00000000
10000000
00000001
00000000
00000000
00000000
00000000
00000000
NAME 1 5

TIL 6c
00000001
00000010
00000100
00000100
00000111
00001111
00001001
00001000
NAME 1 6

TIL 6d
10000000
01100000
10010000
11101001
00110100
11011100
00111100
11100100
NAME 1 7

TIL 6e
00000000
00000000
00000000
00000000
00000110
00001001
00010110
00101011
NAME 1 8

TIL 6f
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME 1 9

TIL 6g
00000111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 10

TIL 6h
00100100
11001000
00111110
00010001
00101110
01011100
10111110
10111010
NAME 1 11

TIL 6i
00000000
00000000
00000000
00000000
10000000
01001000
00100000
00100000
NAME 1 12

TIL 6j
00111011
00111011
00111010
00101101
00010010
00001100
00000000
00000000
NAME 1 13

TIL 6k
10000000
10000011
10000100
00000011
00000101
00000010
00000001
00000000
NAME 1 14

TIL 6l
11111000
01110100
11111010
00001010
11110100
11101000
11110000
00000000
NAME 1 15

TIL 6m
00000000
00000000
00000000
00000000
00000000
00000100
00000000
00000000
NAME 1 16

TIL 6n
00000000
00000000
00000000
00000001
00000010
00000101
00000101
00000010
NAME 1 17

TIL 6o
00000000
01100000
10010000
01101000
01110100
11100100
11000100
10000100
NAME 1 18

TIL 6p
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001111
NAME 1 19

TIL 6q
00000000
00000000
00010000
00000010
00000000
00000000
00000000
10000000
NAME 1 20

TIL 6r
10111100
10011110
01100110
00011100
00000000
00000000
00000000
00000000
NAME 1 21

TIL 6s
01000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 22

TIL 6t
00001000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 23

TIL 6u
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 24

TIL 6v
00001000
11110000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 25

TIL 6w
00110111
01001111
00110000
01011111
00101110
00011111
00000000
00000000
NAME 1 26

TIL 6x
01000001
10100010
10100101
01000101
10001011
00001010
00001010
00001011
NAME 1 27

TIL 6y
01000000
10100000
10100000
11010000
10110000
11011000
10010000
10111000
NAME 1 28

TIL 6z
00000000
00000000
00000000
00000000
00000000
00000011
00000100
00001011
NAME 1 29

TIL 7a
00000000
00000000
10000000
10000000
10000000
00000000
00000000
00000000
NAME 1 40

TIL 7b
00001001
00000110
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 41

TIL 7c
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000000
NAME 1 42

TIL 7d
00000000
00000000
00000000
00000000
00001000
00000000
00000000
00000000
NAME 1 43

TIL 7e
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00001000
NAME 1 44

TIL 7f
00101010
00111001
00111001
00111010
00101101
00010000
00001110
00000001
NAME 1 45

TIL 7g
11101100
00111010
01111101
11111110
11011110
00111101
10111010
11000100
NAME 1 46

TIL 7h
00000000
00000000
00000000
10000000
10000000
00000000
00000000
00000000
NAME 1 47

TIL 7i
00000000
00000000
00000001
00000010
00000101
00001011
00010110
00010110
NAME 1 48

TIL 7j
00000000
00000000
11110000
00001000
11110100
10110100
00000100
10000100
NAME 1 49

TIL 7k
00111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 50

TIL 7l
00010111
00101100
00101100
00010111
00001011
00000100
00000011
00000000
NAME 1 51

TIL 7m
10100000
11010000
11010000
10100100
01000000
10000000
00000000
00000000
NAME 1 52

TIL 7n
00000000
00000000
00000000
00000000
00000110
00001010
00010001
00100101
NAME 1 53

TIL 7o
00000001
00000000
00000000
00000000
10000000
10010000
10000000
01000000
NAME 1 54

TIL 7p
00001011
00000101
00000010
00000001
00000000
00000000
00001000
01000000
NAME 1 55

TIL 7q
11101000
11010000
00100000
11000000
00000000
00000000
00000000
00000000
NAME 1 56

TIL 7r
00000000
00000000
00000001
00000010
00000100
00001000
00010001
00010010
NAME 1 57

TIL 7s
00000000
00000000
10000000
01000000
00100000
00000001
11110000
00011000
NAME 1 58

TIL 7t
01000100
01001100
01101000
10010100
00001000
00000101
00000010
00000001
NAME 1 59

TIL 7u
00100000
10010000
00110000
10010000
11010000
10100000
01000000
10000000
NAME 1 60

TIL 7v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00110000
NAME 1 61

TIL 7w
00010001
00001000
00000100
00000011
00000001
00000000
00000000
00000000
NAME 1 62

TIL 7x
00001000
01111000
10110000
00000000
11100000
11000000
00000000
00000000
NAME 1 63

TIL 7y
00000000
00000000
00010000
00000000
00000000
00000000
00000000
00000000
NAME 1 64

TIL 7z
00000000
00000000
00000000
00000010
00000000
00000000
00000000
00000000
NAME 1 65

TIL 8a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000100
NAME 1 76

TIL 8b
01110000
00100001
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 77

TIL 8c
01100000
10011111
00000011
10001000
01100101
00110111
00010110
00010010
NAME 1 78

TIL 8d
10000000
00000110
00001001
00010000
11100010
00010000
00000000
10010101
NAME 1 79

TIL 8e
00000000
00000000
00000000
10000000
01000000
01000000
10000000
00000000
NAME 1 80

TIL 8f
00010001
00010010
00001010
00000101
00000010
00000001
00000000
00000000
NAME 1 81

TIL 8g
00000010
00100100
01100100
10001000
00010000
00100000
11000000
00000000
NAME 1 82

TIL 8h
00000000
00000000
00000000
00000100
00000000
00000000
00000000
00000000
NAME 1 83

TIL 8i
00000000
00000000
00000000
00000000
00100000
00000010
00000000
00000000
NAME 1 84

TIL 8j
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00000000
NAME 1 85

TIL 8k
00000000
00000000
00000000
00000000
00000000
01111100
10111010
11111101
NAME 1 86

TIL 8l
00000001
00000000
00000000
00000000
00000000
01000000
00000000
00000000
NAME 1 87

TIL 8m
11110010
10111110
10001101
01111110
00000000
00000000
00000000
00000000
NAME 1 88

TIL 8n
10000000
10000000
00000010
00000000
01000000
00000000
00000001
00000001
NAME 1 89

TIL 8o
00000000
00000000
00011110
00100001
01011011
10111001
01101110
01100110
NAME 1 90

TIL 8p
00000000
00000000
00000001
00000110
00001101
00001001
00000110
00000010
NAME 1 91

TIL 8q
00000000
00000000
10000000
01000000
10100000
11010001
00010000
00100000
NAME 1 92

TIL 8r
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 93

TIL 8s
10111100
01011011
00100100
00011000
00000000
00000000
00000000
00000000
NAME 1 94

TIL 8t
10000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 95

TIL 8u
00000000
00000000
00000001
00000000
00000000
00000000
00000000
00000000
NAME 1 96

TIL 8v
00000000
00000000
00000000
00000000
11100000
11010001
10001010
01010101
NAME 2 1

TIL 8w
00000000
00000000
00000000
00000000
11100000
01100000
00100000
01000000
NAME 2 2

TIL 8x
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME 2 3

TIL 8y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10010000
NAME 2 4

TIL 8z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10011100
NAME 2 5

TIL 9a
00000000
00000000
00000000
00000000
00011100
00011010
00010001
00001010
NAME 2 16

TIL 9b
00000000
00000000
00000000
00000000
00011100
00101100
01000100
10101000
NAME 2 17

TIL 9c
00000011
00000011
00000111
00000110
00000100
00000010
00000001
00000000
NAME 2 18

TIL 9d
01001111
10010000
00000111
10001011
01010001
10101010
00000100
10010001
NAME 2 19

TIL 9e
00101100
11101100
01101000
01000101
00101101
00011101
00110111
01010111
NAME 2 20

TIL 9f
00000011
01110010
01110110
10001010
11010010
00010000
01000000
10110011
NAME 2 21

TIL 9g
00101011
00011001
00010100
00010000
10000010
10011000
00111110
00011110
NAME 2 22

TIL 9h
10100000
11100000
10100001
00000011
01011010
00011000
11111000
11111010
NAME 2 23

TIL 9i
10010001
10100000
00010000
00001100
01000011
11111000
01110111
01100000
NAME 2 24

TIL 9j
00000000
10000011
01000101
00101000
01010101
11000010
10010100
10100010
NAME 2 25

TIL 9k
00000100
10000010
10000100
10001010
00010001
00011010
00011100
00000000
NAME 2 26

TIL 9l
00010000
00100000
00010000
10101000
01000100
00101100
00011100
00000000
NAME 2 27

TIL 9m
00000000
00000000
00000000
00000000
00000000
00000000
00011100
00011010
NAME 2 28

TIL 9n
00000001
00000010
00000100
00000110
00000111
00000000
00011100
00101100
NAME 2 29

TIL 9o
00001111
10001000
01101111
10100000
00010011
00000101
00101010
00110100
NAME 2 30

TIL 9p
10110000
10110001
10011101
11001101
11000101
00010001
11001111
00001001
NAME 2 31

TIL 9q
00100000
11110001
10001100
10000000
10101010
10000000
00001000
00000000
NAME 2 32

TIL 9r
00011110
00001001
01000001
00000001
01000100
00010010
01000110
01010100
NAME 2 33

TIL 9s
11100000
11000100
10001000
00101110
00110100
01000000
10000001
00100100
NAME 2 34

TIL 9t
00110011
00100000
00110100
11001000
10101010
01110100
00111100
10011110
NAME 2 35

TIL 9u
00000000
01110000
00110000
11010000
00100001
10000010
11000001
11101010
NAME 2 36

TIL 9v
11000000
11000000
11000000
00000000
00000000
11100000
11010010
00001000
NAME 2 37

TIL 9w
00000000
00000000
00000000
00000000
00000000
11100000
01011000
10011000
NAME 2 38

TIL 9x
00010001
00001010
00000100
00000010
00000100
00001010
00010001
00011010
NAME 2 39

TIL 9y
01000100
10101000
00010001
00100010
00101101
11010000
00010001
01000101
NAME 2 40

TIL 9z
00111001
11100000
01100010
00100010
01001000
10000000
00010000
01000011
NAME 2 41

TIL a0
00000010
00101111
10010010
00100010
00100010
00011010
11011101
11000000
NAME 2 42

TIL a1
00000000
11101111
00000110
00010010
11010100
00010010
01111000
11100000
NAME 2 43

TIL a2
00000101
01100000
00001001
01100000
00001011
00101000
00100011
11001000
NAME 2 44

TIL a3
10001000
00111101
00011100
01000000
00010001
01000000
01001100
00001100
NAME 2 45

TIL a4
11000010
00001101
10010101
00100001
00000000
11010110
00100000
00110000
NAME 2 46

TIL a5
00010100
10010010
10100001
00001000
00010101
11000101
00000101
00001000
NAME 2 47

TIL a6
00011101
11111110
10110111
10101111
01100011
01110101
00110011
00000010
NAME 2 48

TIL a7
00001000
01010000
11100000
00000000
01110000
00100000
00101000
10011000
NAME 2 49

TIL a8
00011100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 2 50

TIL a9
00000101
10000110
11000000
11000001
00000000
00010000
00000010
01000001
NAME 2 51

TIL aa
01100011
00000010
01000010
00000000
01000010
01000000
00000110
01110000
NAME 2 52

TIL ab
00011001
11000000
10101000
00101011
11000100
00001100
10100110
10100010
NAME 2 53

TIL ac
01100100
00010100
00000000
11110100
01110000
00000010
00100100
10000001
NAME 2 54

TIL ad
00001100
00101100
00101000
00000011
00101000
00001010
01000010
01111110
NAME 2 55

TIL ae
11100010
10000111
00101010
10001000
11000001
01110010
00000000
00100100
NAME 2 56

TIL af
00110101
00100001
10000000
01100011
00000111
10100000
00100001
10000000
NAME 2 57

TIL ag
00100111
11010110
00000110
11000010
11100010
00010011
10000000
11000101
NAME 2 58

TIL ah
00000000
00001000
11100000
11101010
01100001
01111100
00001100
00010000
NAME 2 59

TIL ai
00011000
10000000
01000000
10100000
00010000
10110000
01110000
00000000
NAME 2 60

TIL aj
00000000
00011100
00011010
00010001
00001010
00000100
00000010
00000100
NAME 2 61

TIL ak
01110101
10000101
01100000
00110101
00110000
00110010
01111100
00110001
NAME 2 62

TIL al
00000000
01011110
00011100
00000010
00101000
10000010
11101011
10011100
NAME 2 63

TIL am
11010000
11001110
00001110
00000000
00010100
00010000
00100001
00101110
NAME 2 64

TIL an
00000000
11101000
00001011
10100000
00000111
01000001
00001000
01001011
NAME 2 65

TIL ao
00001101
10100001
10000000
00010011
10000000
00000100
01111001
01110111
NAME 2 66

TIL ap
00000000
01100110
00001000
01000010
00100000
10000111
00000000
00011000
NAME 2 67

TIL aq
10100001
00000100
00100001
10100000
10110111
11000000
00001000
00000100
NAME 2 68

TIL ar
10001110
00100001
00101010
00101011
10001000
11100000
10101000
10001000
NAME 2 69

TIL as
00001000
01010111
10100001
00010100
00001111
00000000
00000000
00000000
NAME 2 70

TIL at
00000000
10000011
01000101
00101000
01010101
10000010
01000100
10000010
NAME 2 71

TIL au
00000000
10000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME 2 72

TIL av
00001010
00010001
00011010
00011100
00000000
00000000
00000000
00000000
NAME 2 73

TIL aw
00110001
00110010
01111001
10000100
00000000
00000000
00000000
00000000
NAME 2 74

TIL ax
01000001
00100001
01100001
11100000
00000000
00000000
00000000
00001110
NAME 2 75

TIL ay
11110110
10010000
00011111
10000000
01011000
11010000
11000010
11000010
NAME 2 76

TIL az
00100011
00001000
10000001
00010100
01100000
10001011
10100000
00000001
NAME 2 77

TIL b0
00010111
01000111
00000000
01001111
00000110
11111111
01100011
01111000
NAME 2 78

TIL b1
00111000
10010001
00100000
10100100
00100010
11000000
11001110
00010101
NAME 2 79

TIL b2
00000010
00000001
00110100
00000001
00010000
00000110
00111100
00000110
NAME 2 80

TIL b3
01001100
00001000
00000100
10001101
00100110
11000101
01100000
11010001
NAME 2 81

TIL b4
00000001
00000010
11100011
01100011
00100000
01000000
10000000
00000000
NAME 2 82

TIL b5
01010101
00101000
01000101
10000011
00000000
00000000
00000000
00000000
NAME 2 83

TIL b6
00000000
00000000
00000001
00000001
00000001
00000000
00000000
00000000
NAME 2 84

TIL b7
00001100
00001000
11000100
10100010
00010001
10101010
01000000
00100110
NAME 2 85

TIL b8
11101001
11100110
00100001
00010001
00010001
01000100
00011101
00000000
NAME 2 86

TIL b9
00000100
10000001
00000000
00101010
10000100
00100111
10000010
00000001
NAME 2 87

TIL ba
01000001
01010100
00000010
00001100
00000010
01000000
00010000
01000000
NAME 2 88

TIL bb
01000001
00011100
01000110
01100011
01011000
00000000
11010100
00011000
NAME 2 89

TIL bc
00101101
10001100
00001110
01110110
01111010
11011100
11000000
01000000
NAME 2 90

TIL bd
11100000
01010101
10001010
11010001
11100000
00000000
00000000
00000000
NAME 2 91

TIL be
10000000
01000000
00100000
01100000
11100000
00000000
00000000
00000000
NAME 2 92

TIL bf
01000000
10101010
00010001
10100010
11000101
00001000
00001101
00001110
NAME 2 93

TIL bg
10001100
00000000
10110100
00000000
00000000
01001000
01001000
11111111
NAME 2 94

TIL bh
11101100
10000001
00001100
00010111
00000101
00010101
00101011
10000110
NAME 2 95

TIL bi
00000110
00101000
00000001
00010000
01010000
11100001
00000010
11000100
NAME 2 96

TIL bj
10101000
10000000
11100010
01000001
10101010
00010100
00100010
01000001
NAME 2 97

TIL bk
00000000
10111000
00110100
00100010
10010101
01001000
11000100
11001000
NAME 2 98

TIL bl
00000000
00111000
01011000
10001000
01010000
00100000
01000000
00100000
NAME 2 99

TIL bm
10000001
00000001
00000000
00000000
00000000
00000001
00000000
00000000
NAME 2 100

TIL bn
10101000
01010101
10000010
01000100
10000010
00010001
00000000
00000000
NAME 2 101

TIL bo
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 2 102

TIL bp
00010101
00100010
00110100
00111000
00000000
00000000
00000000
00000000
NAME 2 103

TIL bq
01010000
10001000
01011000
00111000
00000000
00000000
00000000
00000000
NAME 2 104

TIL br
00000001
00000000
00000000
00000000
00000001
00000010
00000011
00000011
NAME 2 105

TIL bs
00010001
10000010
01000100
10000010
01010101
00101000
01000101
10000011
NAME 2 106

TIL bt
00000000
00000000
00000000
00000000
00000000
10000000
10000000
10000000
NAME 2 107

TIL bu
11111111
11110000
11110000
11110010
11110010
11110010
11110010
11110010
NAME 3 1

TIL bv
11110010
11110010
11110010
11110010
11110010
11110010
11110010
11110010
NAME 3 2

TIL bw
11111111
11111111
11111111
11100011
10001000
00000000
00001000
00000000
NAME 3 3

TIL bx
11111111
11111111
11111111
11111111
11111111
01111111
01111111
00111111
NAME 3 4

TIL by
11111110
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME 3 5

TIL bz
10101010
00000000
00001000
00000000
10001000
11100011
11111111
11111111
NAME 3 6

TIL c0
10111111
00111111
01111111
01111111
11111111
11111111
11111111
11111100
NAME 3 7

TIL c1
11111111
11111111
11111111
11111111
11111111
11111111
00011110
01000110
NAME 3 8

TIL c2
11111111
11111111
11100011
10001000
00000000
00001000
00000000
10101010
NAME 3 9

TIL c3
11111111
11111111
11111111
11111111
01111111
01000111
00010001
00000000
NAME 3 10

TIL c4
11111111
11111111
11111111
11111111
11111111
11111111
11100011
10001000
NAME 3 11

TIL c5
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111100
NAME 3 12

TIL c6
11111111
11111111
11111111
11111000
11100000
11000001
10010000
00000000
NAME 3 13

TIL c7
11111111
11111111
11111111
11111111
01111111
00111111
00011111
01001111
NAME 3 14

TIL c8
11111000
11111000
11110000
11110101
11110000
11111000
11111000
11110000
NAME 3 15

TIL c9
00000010
01000011
00000001
01010101
00000001
00000011
00000001
00000000
NAME 3 16

TIL ca
00000000
00001001
00000000
10001000
11100010
11111110
11111111
11111111
NAME 3 17

TIL cb
10010000
00000000
01010100
00000000
00010000
00000000
00010000
11000100
NAME 3 18

TIL cc
00000000
00000000
00010100
00000000
00010000
01110010
00001000
00000000
NAME 3 19

TIL cd
01110001
00000000
00000001
00000000
11000101
11000100
11010001
00000000
NAME 3 20

TIL ce
00000000
00010000
11000000
01000000
01001000
00010000
00000001
00001111
NAME 3 21

TIL cf
00001111
00001111
00011111
10011111
00111111
01111111
11111111
11111111
NAME 3 22

TIL cg
11111111
11111111
11111000
11100010
11000000
11000010
10000000
10101010
NAME 3 23

TIL ch
11111111
11111111
11111111
00111111
00011111
00011111
00001111
10101111
NAME 3 24

TIL ci
11110101
11110000
11111000
11111000
11111100
11111110
11111110
11111100
NAME 3 25

TIL cj
01010000
00000000
01010100
00000100
00011100
00011110
00000000
00000000
NAME 3 26

TIL ck
11111111
01000111
00010001
00000000
00010000
00000000
00010101
00000000
NAME 3 27

TIL cl
11111000
11111000
11110000
11100000
11100001
01000000
01010101
00000000
NAME 3 28

TIL cm
00001010
10100000
10000000
11100000
11000000
01000011
01000000
00010000
NAME 3 29

TIL cn
00000001
10010000
00000111
10001111
00111111
00010001
01000100
00010000
NAME 3 30

TIL co
00011111
01111111
11111000
11110000
11100101
11100000
00000000
00001111
NAME 3 31

TIL cp
11111111
11111111
11111111
01111111
00111111
00111111
00001111
10001111
NAME 3 32

TIL cq
10000000
11000010
11000000
11100010
11111000
11111111
11111111
11111111
NAME 3 33

TIL cr
00001111
00011111
00011111
00111111
11111111
11111111
11111111
11111111
NAME 3 34

TIL cs
11111100
11111000
11111010
11111000
11111100
11111100
11000110
00010000
NAME 3 35

TIL ct
00001100
00011000
10000000
00000000
00100000
00001000
00011100
10010001
NAME 3 36

TIL cu
00010000
00000000
00010000
00000000
11111010
00000000
00000000
11111100
NAME 3 37

TIL cv
00011001
00001100
00100110
00000000
10101010
10000000
00000001
00000001
NAME 3 38

TIL cw
00110000
01100001
01000011
00010110
00000011
10000001
10000000
11000000
NAME 3 39

TIL cx
00000100
10000000
11000101
10100000
10110000
00010001
00000011
00000000
NAME 3 40

TIL cy
00101111
01000000
00001010
01000000
00010101
10000000
00000000
00000110
NAME 3 41

TIL cz
10001111
00001111
00001111
00000111
10000111
00000011
10101011
00000011
NAME 3 42

TIL d0
11111110
11111110
11111100
11111101
11111100
11111100
11111000
11111000
NAME 3 43

TIL d1
00000000
00010000
00000000
01010000
00000000
00000111
00000100
00000100
NAME 3 44

TIL d2
00000001
10000011
00000000
10000011
00001001
10000000
00000000
00000000
NAME 3 45

TIL d3
00000000
00000000
10010100
00000000
00000000
00010010
10010000
10000000
NAME 3 46

TIL d4
00000000
00010000
00000000
00010101
10000000
00010000
00000100
10011100
NAME 3 47

TIL d5
11100000
11000000
01000000
01000000
00000001
00000000
00000110
00010111
NAME 3 48

TIL d6
00100000
00101100
00001100
00100100
00000000
00000000
00000000
01010001
NAME 3 49

TIL d7
00000001
00000000
00011000
00111001
00001001
10100000
00001010
00000010
NAME 3 50

TIL d8
00000111
00000111
00001111
00000111
10000111
00000011
10101011
00000011
NAME 3 51

TIL d9
11110010
11110010
11110010
11110010
11110010
11110010
11100000
11100000
NAME 3 52

TIL da
11110000
11110101
11110000
11111000
11111000
11111100
11111111
11111111
NAME 3 53

TIL db
00000000
00000000
00000001
00000000
00000000
00000000
00000000
11001010
NAME 3 54

TIL dc
00000000
00001101
00000100
00000000
00000000
00000010
01010000
00000000
NAME 3 55

TIL dd
00000010
01011010
00010010
00000001
00010111
00110000
00100000
00101100
NAME 3 56

TIL de
01111000
00000000
10100000
00001100
00011100
10001001
00100000
00000000
NAME 3 57

TIL df
10000010
00110000
00111001
00010000
01000110
00001010
00001010
10010110
NAME 3 58

TIL dg
00000000
11010001
10000000
10000001
10000010
00011110
11010000
11000000
NAME 3 59

TIL dh
01011111
00000000
01001000
00000010
01000100
11100101
11001100
00010010
NAME 3 60

TIL di
10000111
00000111
00001111
00001111
00000111
11010111
00000111
00001110
NAME 3 61

TIL dj
11111111
11111111
11111111
11111111
11111111
11110001
11000100
00000000
NAME 3 62

TIL dk
11111111
11111111
11111111
11111111
11111111
11111111
01111111
00111111
NAME 3 63

TIL dl
11000010
11010000
11000010
11100000
11100000
11110010
11110010
11110010
NAME 3 64

TIL dm
11111111
11111111
11111111
11111110
11111110
11111100
11111101
11111100
NAME 3 65

TIL dn
11000000
00000000
00011111
00010001
00001110
00000000
01010000
00000000
NAME 3 66

TIL do
00000100
00000001
00001111
00001000
00000010
00000000
00101010
00000000
NAME 3 67

TIL dp
00001100
00010010
10000000
11000000
01101000
00000000
00000101
00000000
NAME 3 68

TIL dq
00100100
00000000
00000110
00000011
10111011
00111000
00000000
00000100
NAME 3 69

TIL dr
00000100
10000001
00000000
00010000
00000100
10000001
00000001
01100101
NAME 3 70

TIL ds
11010001
00000000
10001011
01000011
00001000
10001111
10000011
10010001
NAME 3 71

TIL dt
00100000
01110000
00100000
00000010
00101110
10001100
00000000
00000110
NAME 3 72

TIL du
00001000
00010000
00110000
01100000
00001010
00000000
00000000
10000000
NAME 3 73

TIL dv
00000100
00000000
11110101
00110000
10111100
00000001
10001110
00000100
NAME 3 74

TIL dw
00111111
00011111
01011111
00000111
10000011
10001001
00000000
00000010
NAME 3 75

TIL dx
11110010
11110010
11110010
11110010
11110010
11110010
11110010
01110010
NAME 3 76

TIL dy
00010000
00000000
00010001
11000100
11110000
11100000
11100000
11000010
NAME 3 77

TIL dz
11000011
11000011
10000000
00001010
01001000
00001110
00000000
00100011
NAME 3 78

TIL e0
00010110
01010010
00010010
01001010
00010110
00000100
11000001
11010001
NAME 3 79

TIL e1
00101100
11011100
10011010
00010000
11000110
10000000
10000100
10000000
NAME 3 80

TIL e2
01100011
00001101
10001001
10101001
00001001
00001101
00000000
11101000
NAME 3 81

TIL e3
10000000
00000000
00000000
00000101
00000011
01010101
00100001
00111101
NAME 3 82

TIL e4
00000110
00000110
10100000
00101000
01000000
10000000
01001001
00000011
NAME 3 83

TIL e5
00010000
10000110
00001111
00001111
00011111
01111111
11111111
11111111
NAME 3 84

TIL e6
10000001
00101000
11100001
11110000
11110000
11111000
11111110
11111111
NAME 3 85

TIL e7
01100000
01000000
01100000
01100100
00000001
00000011
00001111
11111111
NAME 3 86

TIL e8
01110010
01110010
11000000
10000000
10000111
00000001
01010101
00000001
NAME 3 87

TIL e9
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111100
NAME 3 88

TIL ea
11010000
11000010
11100000
11100000
10000000
00100000
00000001
00100001
NAME 3 89

TIL eb
00000000
00100000
00000000
00000000
00000111
00011111
11111111
11111111
NAME 3 90

TIL ec
00000000
01111001
01111000
00000000
00000100
00100100
10000101
11000000
NAME 3 91

TIL ed
00000011
11000001
00010100
00000000
00000100
00000000
00000101
00000001
NAME 3 92

TIL ee
11100010
11101010
01100000
00110000
00000000
00000000
00000001
11100000
NAME 3 93

TIL ef
00000000
00000000
01001000
00000000
10000000
10000000
10111000
00011011
NAME 3 94

TIL eg
00000111
01000000
00001000
00000110
10000100
00001001
00010000
11000000
NAME 3 95

TIL eh
00011111
01000111
00000011
01000011
00000001
01010101
00000001
01000011
NAME 3 96

TIL ei
11111111
11111110
11111100
11111100
11111000
11111010
11111000
11111100
NAME 3 97

TIL ej
10000111
00010000
00000000
00100000
00000001
10100011
00000001
00100000
NAME 3 98

TIL ek
11111000
11111010
11111000
11111100
11111100
11111110
11111111
11111111
NAME 3 99

TIL el
00000000
10101000
00000010
00100110
00001100
00101001
10000000
11100011
NAME 3 100

TIL em
11111111
00111111
10001111
00000111
00000111
01000011
00001011
11000011
NAME 3 101

TIL en
11101010
11000000
11010101
11000000
11100001
11100000
11110001
11111100
NAME 3 102

TIL eo
10000111
00010000
01000000
00000000
00000000
00001000
00010000
01110101
NAME 3 103

TIL ep
10000001
10100000
00000001
00000100
00001110
00001100
00000100
01010110
NAME 3 104

TIL eq
01000000
01000101
10000000
00101011
10000000
00001000
00000000
00000001
NAME 3 105

TIL er
01000000
01010100
00000111
00001111
00001111
00000011
00001000
00000000
NAME 3 106

TIL es
00000000
01000001
00000000
11100001
11000000
11010101
11000000
01100001
NAME 3 107

TIL et
01111111
00011111
00001111
00001111
00000111
01010111
00000111
00001111
NAME 3 108

TIL eu
11111100
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME 3 109

TIL ev
00000000
00100110
10000010
11110010
11110010
11110010
11110010
11110010
NAME 3 110

TIL ew
11000011
11010000
11000010
11100000
11100000
11110001
11111100
11111111
NAME 3 111

TIL ex
11000001
00000100
10000000
00000100
00010000
00010101
00000000
10000100
NAME 3 112

TIL ey
11111111
01111111
00111111
00111111
00011111
01011111
00011111
00111111
NAME 3 113

TIL ez
11110000
11111000
11111000
11111100
11111111
11111111
11111111
11111111
NAME 3 114

TIL f0
00000100
01000000
00000010
01000111
00011111
11111111
11111111
11111111
NAME 3 115

TIL f1
00001001
10000010
00000110
00011110
11111111
11111111
11111111
11111111
NAME 3 116

TIL f2
00001000
00000000
10101010
00000000
00001000
00000000
10001000
11100011
NAME 3 117

TIL f3
01100000
00110001
10111100
00111111
01111111
01111111
11111111
11111111
NAME 3 118

TIL f4
00001111
00011111
01111111
11111111
11111111
11111111
11111111
11111111
NAME 3 119

TIL f5
10000000
11000100
11110001
11111111
11111111
11111111
11111111
11111111
NAME 3 120

TIL f6
00111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 3 121

TIL f7
11111110
11111000
11110000
11110000
11100000
11101010
11100000
11110000
NAME 3 122

TIL f8
00111111
10001111
00000111
10000111
00000011
10101011
00000011
10000111
NAME 3 123

TIL f9
11111111
11111111
11111111
11111111
10000000
10000000
10011111
10000000
NAME 3 124

TIL fa
11111111
11111111
11111111
11111111
00000000
00000000
11111111
00000000
NAME 3 125

TIL fb
11111111
11111111
11111111
11111100
00000000
00000000
11111100
00000000
NAME 3 126

TIL fc
11111111
11111111
00011111
01000111
00000000
00000000
10100111
00000000
NAME 3 127

TIL fd
11110000
11111000
11111110
11111111
00000000
00000000
11111111
00000000
NAME 3 128

TIL fe
00000111
10001111
00111111
11111111
00000000
00000000
11111111
00000000
NAME 3 129

TIL ff
11110010
11110010
11110010
11110010
00000100
00001000
11110001
00000011
NAME 3 130

TIL fg
00000000
00000000
00000001
00011101
00000001
00000000
00000000
00000000
NAME 4 1

TIL fh
00000000
01010111
10110000
01000001
10111000
01011000
11111111
10000100
NAME 4 2

TIL fi
00000000
01010000
01110000
11111110
00011010
00011110
10000000
00000100
NAME 4 3

TIL fj
00000000
00000011
00000010
00000011
00000000
00000011
00000010
00000011
NAME 4 4

TIL fk
00000000
10000010
10111010
10000010
00000000
10000010
10111010
10000010
NAME 4 5

TIL fl
00000000
01000000
01011011
01010001
00000011
01010101
01011101
01000001
NAME 4 6

TIL fm
00000000
00011100
00000000
00000000
00000010
11010010
01001110
11000000
NAME 4 7

TIL fn
00000000
00000011
00000010
00000011
00001110
11101001
00001100
00000011
NAME 4 8

TIL fo
00000000
10010000
10100000
10001000
00000000
10001000
10100000
10010000
NAME 4 9

TIL fp
00000000
01000001
01001000
01010000
00000101
10000000
01000000
01011101
NAME 4 10

TIL fq
00000000
11011101
01000001
00000000
00000001
00011101
00000001
01000000
NAME 4 11

TIL fr
00000000
01000000
11000000
00000000
11000000
01000000
11000000
00000000
NAME 4 12

TIL fs
00000000
00000000
00000000
11100000
10101110
11100000
00000000
01000000
NAME 4 13

TIL ft
00000000
00000000
00000000
10010111
10010101
10010111
00000000
01100010
NAME 4 14

TIL fu
00000000
01100010
01000100
01100010
00010010
00000000
00010010
00000000
NAME 4 15

TIL fv
11111000
10000000
01000001
00000100
01001011
00100000
00010000
01001000
NAME 4 16

TIL fw
00000100
11000100
00110000
10001110
00001010
00011110
00100000
00000000
NAME 4 17

TIL fx
00000100
00000100
00000100
00000001
00001000
00001000
00001000
00000010
NAME 4 18

TIL fy
00000100
00000100
11100100
00101110
00101010
00000001
00000001
00000000
NAME 4 19

TIL fz
00000001
11100000
10100111
11100101
00000111
11100000
10100010
10000010
NAME 4 20

TIL g0
11000001
00000000
00000111
01110101
00000111
00000000
00000010
00000010
NAME 4 21

TIL g1
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 4 22

TIL g2
00001110
00001010
00001110
00000000
00000100
00000100
00000100
00000000
NAME 4 23

TIL g3
00001110
11101010
00001110
00000000
00000100
00000100
00000100
00111111
NAME 4 24

TIL g4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME 4 25

TIL g5
01000000
01000011
00000000
11100010
10101100
11100010
00000010
00000010
NAME 4 26

TIL g6
01100010
01100010
00101100
00000100
01001100
10010010
00000010
00000010
NAME 4 27

TIL g7
01100000
01000000
00000010
01000001
01000000
01010100
01000011
01110001
NAME 4 28

TIL g8
10001000
00100000
00011111
00000000
01000001
10000010
00010010
00101001
NAME 4 29

TIL g9
00100000
00100000
10100001
10000001
10100001
00100000
00100011
00000010
NAME 4 30

TIL ga
00000000
00000000
11000001
01011101
11000001
00000000
10000000
10011100
NAME 4 31

TIL gb
00000000
00000000
11000000
00110000
10010111
00001000
01000100
00000000
NAME 4 32

TIL gc
00000000
00000000
00000000
01110000
01010000
01110000
00000000
00100000
NAME 4 33

TIL gd
00000010
00000010
00000000
00000111
00000101
00000110
00000001
00000001
NAME 4 34

TIL ge
01101100
00000000
10010100
11100100
00000010
11011110
01011110
11000000
NAME 4 35

TIL gf
00100010
00100000
10110000
01000000
00000000
00000010
00000010
01000010
NAME 4 36

TIL gg
00000010
00000000
00000111
01110101
00000111
00000000
00000000
00000000
NAME 4 37

TIL gh
00001111
00001011
00001111
11100001
10101111
11100001
00000000
01000000
NAME 4 38

TIL gi
00000011
00000011
11110000
10000000
00000000
10000000
00000000
01100001
NAME 4 39

TIL gj
01000000
11000000
00000000
10000000
10000000
10000000
00000000
11111000
NAME 4 40

TIL gk
00000000
00000111
00000101
00000111
00000000
00000000
00000000
00111000
NAME 4 41

TIL gl
00000000
00000111
01110101
00000111
00000000
00000000
00000000
00000000
NAME 4 42

TIL gm
00000110
01100000
00100011
01100010
00000011
00001110
00001010
00001110
NAME 4 43

TIL gn
01010111
00001000
10001011
10111010
10000011
00000000
11100001
00000000
NAME 4 44

TIL go
00000100
00011000
10010000
10100000
10101000
01000110
10000100
01000100
NAME 4 45

TIL gp
00111011
00010000
10011010
00000000
10000100
00000010
11010000
01000110
NAME 4 46

TIL gq
00010000
11000000
00010000
00000000
00000001
00100110
00001000
00001000
NAME 4 47

TIL gr
00100000
00100000
00000000
01110000
01010000
01110000
00000000
00000000
NAME 4 48

TIL gs
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000001
NAME 4 49

TIL gt
00000010
10000100
10000000
10000101
00000000
11000001
01011101
11000001
NAME 4 50

TIL gu
10000000
00000111
11110101
10111111
00101011
11111000
01000000
11011100
NAME 4 51

TIL gv
00000000
00000000
00000000
00111000
10101000
00111000
00000000
00001110
NAME 4 52

TIL gw
00000000
00111000
00101011
00111000
00000000
00010000
00010000
00010111
NAME 4 53

TIL gx
01000000
10111000
00001000
10001000
10000110
11101000
00010000
11010111
NAME 4 54

TIL gy
00111101
01100001
00000000
11100000
10100000
11100000
00000000
00000000
NAME 4 55

TIL gz
01101011
11111000
00000000
00010000
00010000
00010000
00000000
00111000
NAME 4 56

TIL h0
10101000
00111000
00000000
00010000
00001011
00100100
00000100
00001110
NAME 4 57

TIL h1
00000000
00000000
00000000
00111000
10101000
01011111
00000101
00010111
NAME 4 58

TIL h2
00000000
00000000
00000000
00000000
01100000
00101110
01100001
00000010
NAME 4 59

TIL h3
00000000
00001000
00001000
00001000
11100000
10110000
00000000
00000001
NAME 4 60

TIL h4
01000010
01110101
00001000
00001000
00000000
00010010
11010010
00010010
NAME 4 61

TIL h5
00110000
11001101
00001000
00000010
01001000
01000000
01001100
11101000
NAME 4 62

TIL h6
00100100
01110101
00110010
01110000
00100000
10000000
00101000
00100000
NAME 4 63

TIL h7
00011100
11010100
00011100
00000000
00001000
00000100
10010000
00000000
NAME 4 64

TIL h8
00000001
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME 4 65

TIL h9
11000001
01011101
11000001
00000000
10000000
10000000
10000000
00000000
NAME 4 66

TIL ha
11010000
01011001
11000000
00111101
10101111
10111000
10000000
00001110
NAME 4 67

TIL hb
11111010
01011110
00000000
01001100
10000100
00011100
00000000
00001110
NAME 4 68

TIL hc
00000100
00111101
00101000
00111010
00000010
00000010
00000000
00000111
NAME 4 69

TIL hd
00000101
00101111
00001000
11111010
00000010
00000010
00000000
00000111
NAME 4 70

TIL he
00101011
00111000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 4 71

TIL hf
10100001
00010001
00000010
00111101
00101101
00111000
00000100
00001010
NAME 4 72

TIL hg
01010000
00100010
10100010
00110010
01100100
00101011
00000001
00110011
NAME 4 73

TIL hh
01010000
00000100
01011110
00000001
01011001
00000000
01010001
00000000
NAME 4 74

TIL hi
00000001
01001101
00110000
10001001
00100000
00011000
00000100
00000111
NAME 4 75

TIL hj
11000000
01000100
11000100
00000100
10000001
10001111
10001011
00001110
NAME 4 76

TIL hk
00010100
00001001
00100111
11001011
10110100
00001000
00010000
11000110
NAME 4 77

TIL hl
00000000
00001000
00100000
00001000
10010000
00111010
10110101
10011100
NAME 4 78

TIL hm
00000000
00010000
00000100
00001000
00000000
00011100
11010100
00011100
NAME 4 79

TIL hn
11000001
01011101
11000001
00000000
00000000
00000000
00000000
00000000
NAME 4 80

TIL ho
11001010
00101110
00101110
11100000
00000000
01000000
01000000
01000000
NAME 4 81

TIL hp
11101010
11110010
10110101
11111100
00000000
01001000
01001000
01001000
NAME 4 82

TIL hq
00000101
00011011
11010100
00011100
00000000
00001000
00000101
00010010
NAME 4 83

TIL hr
01110101
01110111
10010111
10000001
11000011
10001101
00000000
00100100
NAME 4 84

TIL hs
00000000
01110000
01010000
01110111
11100101
00100111
00100000
00100010
NAME 4 85

TIL ht
00000000
01110000
01010111
01110000
00000000
00100000
00100000
00100000
NAME 4 86

TIL hu
00001000
01111000
01010000
01101100
00010101
00111100
00100000
00100000
NAME 4 87

TIL hv
00001000
00001000
00000000
00011100
11010100
00011100
00000000
00000000
NAME 4 88

TIL hw
01100000
00101110
01100000
00000000
00001110
00001010
00001110
00000000
NAME 4 89

TIL hx
00000001
00011101
00000001
00000000
01000010
10000001
00100100
00000000
NAME 4 90

TIL hy
11000001
01000001
11000001
00000000
01110000
01010000
01110000
00000000
NAME 4 91

TIL hz
11100000
01010001
11011011
00000000
00000000
00000000
00000000
00000000
NAME 4 92

TIL i0
11110000
01010000
01110000
00000000
00000000
00000000
00000000
00000000
NAME 4 93

TIL i1
00000000
00000000
00000000
00000000
00011100
00010101
00011100
00000000
NAME 4 94

TIL i2
00000000
00000000
00000000
00000000
00011100
11010100
00011100
00000000
NAME 4 95

TIL i3
00000000
11100000
10101110
11100000
00000000
00000000
00000000
00000000
NAME 4 96

TIL i4
00000000
11111100
10110101
11111100
00000000
00000000
00000000
00000000
NAME 4 97

TIL i5
00000100
00000100
10100000
01010000
01100000
00010000
00100101
00100000
NAME 4 98

TIL i6
01100100
10011101
00111110
00110010
00000000
10000100
00000000
00111011
NAME 4 99

TIL i7
00000010
00000010
00010000
00010111
00110101
01100111
10100000
11100000
NAME 4 100

TIL i8
00000000
01110000
01010111
01110000
00000000
00000000
00001110
00001010
NAME 4 101

TIL i9
00000000
01110000
01010000
01110000
00000000
00000000
00001110
11101010
NAME 4 102

TIL ia
00000100
00000100
00000100
00000000
00001110
00001010
00001110
00000000
NAME 4 103

TIL ib
00000000
00000000
00000000
00000000
00110001
00001000
10000110
01001100
NAME 4 104

TIL ic
00100000
00100000
00100000
00000000
00110000
00010000
00010000
10100000
NAME 4 105

TIL id
00000000
00000000
00000000
00001110
00001010
00001110
00000000
00000100
NAME 4 106

TIL ie
00000000
00000000
00000000
00001110
11101010
00001110
00000000
00000100
NAME 4 107

TIL if
00001000
00001000
00001000
00000000
00011100
00010101
00011100
00000000
NAME 4 108

TIL ig
00001111
00001101
00001111
00000000
00011110
11010110
00011110
00000000
NAME 4 109

TIL ih
00000111
01110101
00000111
00000000
00000010
00000010
00000010
00000000
NAME 4 110

TIL ii
00000111
00000101
00000111
00000000
00000010
00000010
00000010
00000000
NAME 4 111

TIL ij
00100001
01101011
01000100
00010011
00000001
00000000
00110000
00010000
NAME 4 112

TIL ik
00000101
11100111
10011110
10000000
00001000
00010000
01000000
00000000
NAME 4 113

TIL il
00000000
11100000
10100000
11100000
00000000
01000000
01000000
01000000
NAME 4 114

TIL im
00001110
00000000
00000100
00000100
00000100
00000000
00011101
00010100
NAME 4 115

TIL in
00001110
00000000
00000100
00000100
00000100
00000000
10000000
00001110
NAME 4 116

TIL io
00000000
00000000
00000000
00000000
00000000
00001110
00000000
00000000
NAME 4 117

TIL ip
00000000
00111000
00101011
00111000
00000000
00010000
00010000
00010000
NAME 4 118

TIL iq
10000010
10000001
00000100
10110100
00000101
11001000
10000000
10000110
NAME 4 119

TIL ir
10010000
01010000
10110000
01000000
00100000
00100000
00100000
01000000
NAME 4 120

TIL is
00000100
00000100
00000011
00000010
00000011
00000100
00000100
00000100
NAME 4 121

TIL it
00000100
00000100
10111000
10101000
10111000
00000100
00000100
00010000
NAME 4 122

TIL iu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00011100
NAME 4 123

TIL iv
00000111
00000101
00000111
00000000
00000000
00000000
00000000
00000000
NAME 4 124

TIL iw
00000111
01001101
00101100
00111000
00000000
00010000
00010000
00010000
NAME 4 125

TIL ix
00000000
00111000
10101000
00111000
00000000
00010000
00010000
00010000
NAME 4 126

TIL iy
00000111
00000101
00000111
00000000
00000000
00000011
00000010
00011111
NAME 4 127

TIL iz
00010000
01100000
01010011
01001010
00101011
10111011
10111010
01000111
NAME 4 128

TIL j0
00001000
00001000
00100110
00100111
11001000
11110000
10100000
10100000
NAME 4 129

TIL j1
00000000
11100000
10010000
10010000
01110000
00000000
00100000
00100000
NAME 4 130

TIL j2
00011100
11101110
10110011
11110001
00011000
01001100
01001110
01000111
NAME 4 131

TIL j3
01101010
00001110
10001000
11001000
11000110
01100000
00111000
00110000
NAME 4 132

TIL j4
00000000
00001110
00000000
00000000
00001110
00000000
00000000
00000000
NAME 4 133

TIL j5
00000000
00111000
00101011
00111000
00000000
00000000
00000000
00000000
NAME 4 134

TIL j6
10000100
00000111
10000000
00111000
00000000
00000000
00000000
00000000
NAME 4 135

TIL j7
10110000
01010000
01110000
00000000
00000000
00000000
00000000
00000000
NAME 4 136

TIL j8
00000000
00001110
00001010
00001110
00000000
00000000
00000000
00000000
NAME 4 137

TIL j9
00010101
00010010
11101010
00000010
00001000
00001000
00000000
11101110
NAME 4 138

TIL ja
11010100
00011100
00000000
00001000
00001000
00001000
00000000
00011100
NAME 4 139

TIL jb
00000000
00111000
10101000
00111000
00000000
00000000
00111000
00101011
NAME 4 140

TIL jc
00010100
00011101
00000001
00001000
00001000
00001011
00111010
10100110
NAME 4 141

TIL jd
00000100
00001101
01010001
10010001
10101001
00001010
00000010
00101111
NAME 4 142

TIL je
00100000
00000000
01110000
01010111
10110001
01011101
01000001
10000000
NAME 4 143

TIL jf
00100000
00000000
01110000
01010000
10110000
01000000
11000000
00000000
NAME 4 144

TIL jg
00000001
11100000
10101110
11100000
00111000
00101011
00111000
00000000
NAME 4 145

TIL jh
11010001
11100010
10100011
11100000
00111001
10101001
00111001
00000000
NAME 4 146

TIL ji
10001101
10111010
10000011
00000000
00000001
00000001
00000001
00000000
NAME 4 147

TIL jj
10100000
11100001
00000000
01000000
01000000
01000000
00000000
11100000
NAME 4 148

TIL jk
00010100
11011100
00000000
01000000
01000000
01000000
00000000
11100000
NAME 4 149

TIL jl
00111000
00000000
00010010
00010000
00010100
00000101
00111100
00101010
NAME 4 150

TIL jm
00100001
00000001
00011010
10001000
00110000
00100000
00011000
00011101
NAME 4 151

TIL jn
11000000
11000000
00011100
00000000
00001001
00001001
00001001
00001110
NAME 4 152

TIL jo
10000000
10000000
10000000
00000000
11000001
01011101
11000001
00001110
NAME 4 153

TIL jp
10000000
10000000
10000000
00000000
10110000
00010111
10101001
00010011
NAME 4 154

TIL jq
00010000
00010000
00010110
00001001
01000011
01000001
01000000
00100000
NAME 4 155

TIL jr
00010011
00001110
10000111
11001100
10010000
01101000
00001000
00001000
NAME 4 156

TIL js
10000011
10111010
10000011
00000000
00000000
00000000
00000000
00000000
NAME 4 157

TIL jt
10101110
11100001
00000001
00000001
00000000
00000000
00000000
00000000
NAME 4 158

TIL ju
10100000
00100001
01011101
11000001
00000000
10000000
10000000
10000000
NAME 4 159

TIL jv
00000000
11000000
01000000
11000000
11100000
00101110
01100000
10000000
NAME 4 160

TIL jw
00000000
00000000
01110111
01010101
10010000
10100101
11000001
00100010
NAME 4 161

TIL jx
00111001
00000010
01110101
01010000
00000001
01010000
01000001
00100010
NAME 4 162

TIL jy
10100001
00000010
00001011
00110010
10010100
01110101
00000111
00000000
NAME 4 163

TIL jz
00010010
11010010
10011100
10000100
10001000
00000010
00000000
00000000
NAME 4 164

TIL k0
11101010
00001110
00111000
00100011
00001000
00000010
00010110
00001000
NAME 4 165

TIL k1
00100000
00100000
00100111
10010000
01000000
01000011
01000010
00001011
NAME 4 166

TIL k2
00011000
00111100
10000101
00001100
00010000
00100000
01011000
10101000
NAME 4 167

TIL k3
00000000
00011100
11010100
00011100
00111000
00101000
00111011
00000010
NAME 4 168

TIL k4
11100000
10101110
11100000
00000000
01101000
01000000
11100100
00110011
NAME 4 169

TIL k5
00001110
00001010
00001101
00000010
00000100
00000100
00000111
00000000
NAME 4 170

TIL k6
00011000
11110000
00111001
00100000
00101001
00000010
10100011
10000001
NAME 4 171

TIL k7
00001000
00001000
00001000
00000000
00011100
11010100
00011100
00000000
NAME 4 172

TIL k8
00000000
00000001
00000001
00000001
00000000
00000000
00000000
00000000
NAME 4 173

TIL k9
00000000
11000001
01011101
11000001
00000000
00000000
00000000
00000000
NAME 4 174

TIL ka
01000000
10000000
00000000
11000000
11100000
10101110
11100000
00000000
NAME 4 175

TIL kb
01100001
01000101
00110000
01010101
10011001
10101010
11101110
00000000
NAME 4 176

TIL kc
01000010
01010000
00000111
01010101
01111001
11101010
00001110
00000000
NAME 4 177

TIL kd
00000010
00001000
00000100
00000000
00001110
00001010
00001110
00000000
NAME 4 178

TIL ke
00010010
00000010
00000010
00100001
00010000
11010010
00100101
00111000
NAME 4 179

TIL kf
00010000
00000000
00111000
10101000
00111000
00111000
10101000
00111000
NAME 4 180

TIL kg
00111000
00000000
00000000
00000000
00000000
00000000
11100000
10101110
NAME 4 181

TIL kh
00010000
00010010
00010010
00001110
00001011
00001100
11110010
10110000
NAME 4 182

TIL ki
00110000
00010000
00000001
01000010
00001000
00000111
11000101
00001111
NAME 4 183

TIL kj
00001101
00001000
00001100
00000010
00011111
00010101
00011100
00000000
NAME 4 184

TIL kk
11100001
10100010
00100101
10111010
10011111
11010100
00011100
00000000
NAME 4 185

TIL kl
00000000
00000000
00000000
00000001
00000001
00000010
00000010
00000011
NAME 4 186

TIL km
00000000
00000000
00000000
11000001
01011101
01010010
10011001
00000000
NAME 4 187

TIL kn
00000100
00000100
00000100
11000000
01001110
11001010
00001110
10000000
NAME 4 188

TIL ko
00000100
00000100
00000100
00000000
00000000
11100001
01101101
01000101
NAME 4 189

TIL kp
00000000
00000000
00000000
00000000
00011100
11010100
00101100
00010000
NAME 4 190

TIL kq
00000000
00010000
00010000
00010000
00000000
00111000
00101011
00111000
NAME 4 191

TIL kr
00000000
00010011
00010010
00011100
00001000
00110101
10101000
00111111
NAME 4 192

TIL ks
11100000
10000011
10110010
01001100
11000000
11100000
01000000
00000010
NAME 4 193

TIL kt
00001100
00000000
00100000
00000000
10110001
00000000
00100000
00000000
NAME 4 194

TIL ku
01010000
00100000
00011000
00001000
10011000
01000000
01000000
00000000
NAME 4 195

TIL kv
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01110000
NAME 4 196

TIL kw
00000000
00000000
11100000
10101110
11100000
00000000
01000011
10000010
NAME 4 197

TIL kx
00000000
00000000
11100000
10100000
11100000
00000000
10000111
11110101
NAME 4 198

TIL ky
00000000
00000001
00000001
00000001
00000000
00000011
00000010
00000011
NAME 4 199

TIL kz
10000000
00111100
00000001
00000000
10011001
01001010
10111000
10000000
NAME 4 200

TIL l0
10000000
10000000
00000000
11000000
01000000
01000000
00010000
00100000
NAME 4 201

TIL l1
01101111
00000100
00111101
00100000
00110001
00010001
11100000
00000010
NAME 4 202

TIL l2
00001000
00001000
01111000
01000000
11101100
00000100
00001100
00000000
NAME 4 203

TIL l3
00001110
00001010
00010010
00010100
00011000
00000100
00001001
00001000
NAME 4 204

TIL l4
00001110
11101010
10010110
11001000
00000100
00000100
11100100
00001000
NAME 4 205

TIL l5
00000100
00000100
00000010
00001101
00001010
00001110
00000000
00000000
NAME 4 206

TIL l6
10010100
00111101
00101000
00100001
11101010
00001110
00000000
00000000
NAME 4 207

TIL l7
00000000
00110010
01110101
10011010
00000100
00001000
00001010
00001110
NAME 4 208

TIL l8
11100000
10111100
00110011
00101001
00000111
01000000
01001110
01001010
NAME 4 209

TIL l9
00000000
00000000
00000001
00011101
00000001
00000000
00000001
00011101
NAME 4 210

TIL la
00000000
00000000
11000000
01000000
11000000
00000000
11000000
01000000
NAME 4 211

TIL lb
01010111
01110000
00000000
00100000
00100000
00100000
00000000
00000000
NAME 4 212

TIL lc
00100011
00010000
10000001
01001111
00010001
00100000
00000111
00000101
NAME 4 213

TIL ld
10000111
00000000
11000010
01000010
11000010
00000000
00000111
01110101
NAME 4 214

TIL le
00000000
00000000
00000111
00000101
00000111
00000000
00000111
00000101
NAME 4 215

TIL lf
00000011
00000000
00000110
01110100
00000110
00000000
00000100
01110100
NAME 4 216

TIL lg
10001001
00000000
00000000
00000000
00000000
00000000
10001001
10100000
NAME 4 217

TIL lh
00100110
00010000
00000000
00001000
00100000
00101011
00100100
01010100
NAME 4 218

TIL li
10011000
00001111
00011000
00000000
01100000
11000000
01100000
00000000
NAME 4 219

TIL lj
01111000
01010100
01101010
00010101
00111100
00100000
00100000
00000000
NAME 4 220

TIL lk
00000110
11001001
01010000
11010111
00011100
00000011
00000010
00000011
NAME 4 221

TIL ll
00000000
10000011
10111010
10000011
00000000
10000011
10111010
10000011
NAME 4 222

TIL lm
00000000
10000000
10000000
10000000
00000000
10000000
10000000
10000000
NAME 4 223

TIL ln
00000000
00011100
00010010
00011001
00000111
00000000
00000000
00000000
NAME 4 224

TIL lo
01000010
00000100
10001011
01110101
00000111
00000000
00000000
00000000
NAME 4 225

TIL lp
00000000
00000000
00000000
00000000
00000000
00000000
01100000
10000000
NAME 5 1

TIL lq
00000000
00000000
00000000
00000000
00000000
00000010
00000000
00000000
NAME 5 2

TIL lr
00100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 3

TIL ls
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME 5 4

TIL lt
01000000
10011000
01000100
00000100
00010000
00000000
01100000
00000000
NAME 5 5

TIL lu
00000000
00000010
00000101
00000100
00000000
00000000
00000000
00000000
NAME 5 6

TIL lv
01000000
01000100
11110100
01001000
01000000
00100000
11000000
00000000
NAME 5 7

TIL lw
00000000
00000000
00100000
00000000
00000000
00000000
00000000
00000000
NAME 5 8

TIL lx
00000000
00000000
00000010
00000000
00000000
00001000
00000000
00000000
NAME 5 9

TIL ly
00000000
00000000
00000000
00000000
00000000
00000100
00000000
00100000
NAME 5 10

TIL lz
00000000
00000000
00000100
00000000
00000000
00000000
00000000
00000000
NAME 5 11

TIL m0
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME 5 12

TIL m1
00000000
00000000
00000000
00000000
00000100
00000000
00000000
00000000
NAME 5 13

TIL m2
00000000
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 14

TIL m3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000
NAME 5 15

TIL m4
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 16

TIL m5
00000000
00000000
00001000
00000000
00000000
00000000
00000000
00000000
NAME 5 17

TIL m6
00000000
00000000
01000000
00000000
00000000
00000000
00000000
00000000
NAME 5 18

TIL m7
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000000
NAME 5 19

TIL m8
00001100
00001100
00011100
01100000
11000000
00110101
10010010
11010010
NAME 5 20

TIL m9
00000000
00000000
00000000
11000000
11000000
11000000
00100000
00000000
NAME 5 21

TIL ma
00000000
00000000
00000000
00000000
10000000
00000000
00000000
00000000
NAME 5 22

TIL mb
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000010
NAME 5 23

TIL mc
00000000
00100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 24

TIL md
00000000
00000000
00000000
00100000
00000000
00000000
00000000
00000000
NAME 5 25

TIL me
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00010000
NAME 5 26

TIL mf
00000000
00000001
00000000
00000001
00000000
00000000
00000000
00000000
NAME 5 27

TIL mg
10011110
01001010
10000100
01001010
10000100
00000000
00110000
00110000
NAME 5 28

TIL mh
00001100
00001100
00010010
00100001
11001100
11001100
00100001
00010010
NAME 5 29

TIL mi
00000000
00000000
00000000
00000010
11000000
11000000
00000000
00000000
NAME 5 30

TIL mj
00000000
00000000
00000001
00000000
00000000
00001000
00000000
00000000
NAME 5 31

TIL mk
00100000
00000000
00000000
00000000
00000000
00000100
00000000
00000000
NAME 5 32

TIL ml
00000000
00000010
00000000
00000000
00000000
00000000
00000001
00000000
NAME 5 33

TIL mm
00000000
00000000
00000000
00000000
00000000
00000000
00000100
00000000
NAME 5 34

TIL mn
00001100
00001100
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 35

TIL mo
00000000
00000000
00000000
00000000
00000000
10000001
00000000
00000000
NAME 5 36

TIL mp
00000000
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 37

TIL mq
00000000
00000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME 5 38

TIL mr
00000000
00000000
00000000
00000001
00000000
00000000
00001000
00000000
NAME 5 39

TIL ms
00000000
00000000
00000000
00000100
00000101
00000010
00000000
00000000
NAME 5 40

TIL mt
11000000
00100100
01000000
01001000
11110100
01000100
01000000
10000000
NAME 5 41

TIL mu
00000000
00000000
00000000
00010000
00000000
00000000
00000000
00000000
NAME 5 42

TIL mv
00000000
00000000
00000000
00000000
00000000
00000000
00100000
00000000
NAME 5 43

TIL mw
00000000
00000000
00000010
00000000
00000000
00000000
00000000
00000000
NAME 5 44

TIL mx
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME 5 45

TIL my
00000000
00000000
00000000
00000000
00000000
00000000
11000000
00000000
NAME 5 46

TIL mz
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME 5 47

TIL n0
00000000
00000000
00000000
00000000
00110000
00001000
00010000
00010010
NAME 5 48

TIL n1
00000000
00000000
00000000
00100000
00000010
00000000
00000000
00000000
NAME 5 49

TIL n2
01100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 50

TIL n3
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 51

TIL n4
00000000
00000100
00001011
00001000
00000000
00000000
00000001
00000000
NAME 5 52

TIL n5
10000000
10001000
11101000
10010000
10000000
01000000
10000000
00000000
NAME 5 53

TIL n6
00000000
01000000
00000000
00000000
00000001
00000001
00000000
00000000
NAME 5 54

TIL n7
01111100
01101100
01000010
01010100
10000000
10000000
00010100
00101010
NAME 5 55

TIL n8
00000001
00000000
00000000
00000000
11000000
11000000
00000100
00000000
NAME 5 56

TIL n9
01111101
10010001
00010000
00100000
00011000
00000000
00000000
00000000
NAME 5 57

TIL na
00000000
00000000
00000000
00000000
00000010
00000000
00000000
00000000
NAME 5 58

TIL nb
00001000
00000000
00000000
00000000
00000000
00000000
00000000
00000010
NAME 5 59

TIL nc
00000000
00000000
00000100
00000000
00000000
00110000
00001000
00010000
NAME 5 60

TIL nd
00010100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 61

TIL ne
00000000
00000000
00000000
00000001
00100000
00000000
00000000
00000000
NAME 5 62

TIL nf
00000001
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 63

TIL ng
00010010
01111101
10010001
00010000
00100000
00011000
00000000
00000000
NAME 5 64

TIL nh
00000000
00000000
00000000
00000000
00000001
00000000
00000000
00000000
NAME 5 65

TIL ni
00000000
00001000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 66

TIL nj
01000110
00001000
00000100
00100100
01011110
01000100
00000100
00000010
NAME 5 67

TIL nk
00000000
00000000
00000000
00000000
00000000
00000000
00000100
00000111
NAME 5 68

TIL nl
00000000
00001000
00000000
00000000
00000000
00000000
10000000
10000000
NAME 5 69

TIL nm
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000000
NAME 5 70

TIL nn
00001100
00000000
00000000
00000000
00100000
00000000
00000000
00000000
NAME 5 71

TIL no
00001010
00010000
01100110
01100110
00010000
00001001
00000110
00000110
NAME 5 72

TIL np
00010000
10100000
01100000
01100000
10000000
00000000
00000000
00000000
NAME 5 73

TIL nq
00000000
00001000
00000000
00000000
00000000
00000000
00000110
00111110
NAME 5 74

TIL nr
00000001
00000000
00000001
00011011
00011010
00001101
00000010
00000001
NAME 5 75

TIL ns
11000000
01000000
10100000
01011000
00101100
01101100
11000000
00000000
NAME 5 76

TIL nt
00000000
00010000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 77

TIL nu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000110
NAME 5 78

TIL nv
00000000
00000000
00000000
00000000
01100000
01100000
10010000
01011100
NAME 5 79

TIL nw
00001000
00000000
00000000
00000000
00000001
00000001
00000010
01001100
NAME 5 80

TIL nx
00000000
00001000
00000000
00000000
10000001
11110000
00101000
01001000
NAME 5 81

TIL ny
00110001
00100000
01100110
01100110
00010000
00001001
00000110
00000110
NAME 5 82

TIL nz
01100000
01000000
11000000
01100000
10000000
00000000
00000000
00000000
NAME 5 83

TIL o0
11000000
11000000
00000000
00000000
00000000
00000000
00000001
00000001
NAME 5 84

TIL o1
00000000
00000000
00000000
00110000
00001000
00010000
00010010
01111101
NAME 5 85

TIL o2
00000000
00000000
00000000
00000000
00000000
00000000
01000000
00000000
NAME 5 86

TIL o3
00000000
00000000
00000000
10000000
00000000
00000000
00000000
00000000
NAME 5 87

TIL o4
00000011
00000010
00001100
00001110
00000000
00000000
00000000
00000000
NAME 5 88

TIL o5
00010101
10000000
10111000
11011101
00000000
00000000
00000000
00000000
NAME 5 89

TIL o6
00001100
00000110
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 90

TIL o7
00001100
00001100
10010000
01100000
01100000
00000000
00000000
00000000
NAME 5 91

TIL o8
00000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 92

TIL o9
00000100
00000000
00000000
00000010
00000000
00000000
00000000
00000000
NAME 5 93

TIL oa
10010001
00010000
00100000
00011000
00000000
00000000
00000000
00000000
NAME 5 94

TIL ob
00000000
00000000
00000001
00000000
00001000
00000000
00000000
00000000
NAME 5 95

TIL oc
00000000
00000000
00000000
01011011
01101010
01111011
00110100
01010011
NAME 6 1

TIL od
00000000
00011101
00001110
10010111
10011100
10000010
00011101
10010101
NAME 6 2

TIL oe
00000000
01010110
00110001
00010000
10000001
11010010
11010000
00111110
NAME 6 3

TIL of
00000000
10100000
00010111
11011101
11101111
00101010
11001010
00010101
NAME 6 4

TIL og
00000000
00000000
01110000
01010000
01110000
10000000
01110001
11010001
NAME 6 5

TIL oh
00000000
10110000
11000011
01110001
10010101
11010011
00101001
01011001
NAME 6 6

TIL oi
00000000
00011010
01011101
00010010
10101101
00110110
11000101
00000110
NAME 6 7

TIL oj
00000000
00000001
10111010
10101010
10000010
10100101
11010010
10110110
NAME 6 8

TIL ok
00000000
01010101
01011101
10100100
01000000
01000000
01100100
10000010
NAME 6 9

TIL ol
00000000
01000000
11000000
00111000
00101000
00111000
00000000
01111000
NAME 6 10

TIL om
00000000
00000000
00000000
00000000
00000000
00000000
00001110
00001010
NAME 6 11

TIL on
00000000
00000000
00000000
00000000
00000000
00000000
11101110
10101010
NAME 6 12

TIL oo
00000000
00000001
00000000
00000001
00000001
00001110
00001010
00001110
NAME 6 13

TIL op
00000000
00011010
11101011
10001001
01100010
11001101
10111001
11010101
NAME 6 14

TIL oq
00000000
00000000
01000000
00111000
11101000
00111000
01000000
01010110
NAME 6 15

TIL or
00001110
01010011
00110100
01111011
01101010
01011011
01010100
01000100
NAME 6 16

TIL os
10011101
10000000
00000000
10000000
10000000
10000000
00000000
00000000
NAME 6 17

TIL ot
10010110
01110101
00000011
00000000
00000011
00000010
00000011
00000000
NAME 6 18

TIL ou
10100000
11000110
11011110
00011011
11000011
11101110
10010011
01010100
NAME 6 19

TIL ov
11110001
00000000
11110001
01010001
11110001
10000000
10000001
00000001
NAME 6 20

TIL ow
11011000
01000100
11001000
01010000
10001000
00101010
11000110
00100001
NAME 6 21

TIL ox
00001100
10010001
01010101
01000000
00000000
00101011
01010111
01000101
NAME 6 22

TIL oy
11000010
01001111
10110100
00011010
10001111
00110100
11101111
01011100
NAME 6 23

TIL oz
01000000
10011100
00110010
01000011
00101110
10100111
01110100
10011100
NAME 6 24

TIL p0
00101000
00111000
01000000
10111000
10101000
10111000
00000111
00000101
NAME 6 25

TIL p1
00001110
00000001
00001110
00001011
00001110
00000001
01111001
01011111
NAME 6 26

TIL p2
11101110
01010011
01001100
10111001
01001110
01010011
11101100
10101001
NAME 6 27

TIL p3
00000000
10111011
10101010
10111011
01010100
10010011
11101110
10010011
NAME 6 28

TIL p4
00100000
10110101
10000001
10001110
00110000
10100100
10111101
10001001
NAME 6 29

TIL p5
00000010
01010110
01010000
01001110
00110010
01000110
11001000
11011110
NAME 6 30

TIL p6
11101101
10101011
11101111
00010110
11100101
10111000
11100101
00010110
NAME 6 31

TIL p7
01010100
00000000
01010100
00010100
01010100
00000000
01010100
01000100
NAME 6 32

TIL p8
00000011
00000010
00000011
00000000
00000000
00000000
00000000
00000000
NAME 6 33

TIL p9
10111011
10101010
10100110
00010101
00011101
00000010
00011100
00010111
NAME 6 34

TIL pa
10000001
10000000
01011100
01010100
11011100
10100000
10011100
01110100
NAME 6 35

TIL pb
10110111
01110111
00000000
00000000
00000000
00011101
00010100
00011110
NAME 6 36

TIL pc
10001101
01110000
00000000
00000000
00001110
11010110
11010101
00000110
NAME 6 37

TIL pd
11000010
00011101
00010101
00011101
11101110
10101010
11101110
01010000
NAME 6 38

TIL pe
10111101
11001001
01001001
11011110
11110010
10110010
11110010
00011000
NAME 6 39

TIL pf
11011011
01010100
11000000
10110100
01100000
01101000
01010100
01100000
NAME 6 40

TIL pg
01111001
01001000
00000111
00000101
01001111
10000000
00000111
11101011
NAME 6 41

TIL ph
11101110
00000011
00000010
00000011
00000000
00000000
00000000
00000000
NAME 6 42

TIL pi
01010100
10111011
10101010
10111011
00000000
00000000
00000000
00000000
NAME 6 43

TIL pj
00110001
10100110
10111001
10000101
00111011
00101010
00111011
00000000
NAME 6 44

TIL pk
00010010
00000110
00111000
01000000
10111000
10101000
10111000
00000000
NAME 6 45

TIL pl
11101111
10101011
11011000
00101110
00111111
00000000
00110010
00101000
NAME 6 46

TIL pm
01010100
00000000
00011101
00010101
00011101
00101010
00001001
00110111
NAME 6 47

TIL pn
00011100
00000010
00011101
00011011
00010111
00001110
00000001
00001110
NAME 6 48

TIL po
10011100
10100000
11011100
10111010
01110110
11101110
01010000
01001110
NAME 6 49

TIL pp
00000101
00011100
00010101
00011000
00000010
00011100
00010010
00011011
NAME 6 50

TIL pq
01000000
10101000
00101001
10010001
10101001
01011001
00000110
01100101
NAME 6 51

TIL pr
00111001
01001001
00000111
11110110
00001011
00101101
11001001
10101011
NAME 6 52

TIL ps
11111001
10101001
11111001
00010101
00000000
00000000
11100010
10001110
NAME 6 53

TIL pt
00001011
00100101
00001100
00110101
00001101
01100010
11010011
00000001
NAME 6 54

TIL pu
00101010
10011011
01011011
10010110
10011001
10011011
10110111
10100000
NAME 6 55

TIL pv
00000000
00000000
00000000
01110111
01010101
01110111
00001010
01110010
NAME 6 56

TIL pw
00000000
00000000
00000000
01110000
01010000
01110000
10000000
01110000
NAME 6 57

TIL px
00110010
00000000
00111111
00101110
00110101
00000000
00000000
11101101
NAME 6 58

TIL py
00001001
00101010
00011101
00010101
00011101
00000000
00000000
01011011
NAME 6 59

TIL pz
11000000
00000000
11000000
01000000
11000000
00000000
00000011
10000010
NAME 6 60

TIL q0
00000000
00000000
00000000
00000000
00000000
00000000
10111011
10101010
NAME 6 61

TIL q1
00001011
00001110
00000001
00001110
00001010
00001110
10000000
10000000
NAME 6 62

TIL q2
10111010
01001110
01010000
11101110
10101010
11101110
00000000
00000000
NAME 6 63

TIL q3
01110000
00000101
00000111
00000000
00000000
00000000
00000000
00000000
NAME 6 64

TIL q4
01110000
01011101
01111001
00001011
00001110
00000001
00001110
00001010
NAME 6 65

TIL q5
00110110
01001000
00000011
01111101
01000000
00111001
00000000
10101101
NAME 6 66

TIL q6
11111111
11000010
00000011
00111001
01111101
01011001
10101011
10010101
NAME 6 67

TIL q7
10010011
00110101
10110111
01000000
11000000
00000000
11000000
01000000
NAME 6 68

TIL q8
00000000
00000000
00000000
00000000
00000000
00000000
01110111
01010101
NAME 6 69

TIL q9
00000111
00000101
00001001
00001110
00001100
00000000
01111101
01011100
NAME 6 70

TIL qa
00101000
00100101
00000011
11000001
01111011
10100100
00001000
10110000
NAME 6 71

TIL qb
11010000
01110000
10000000
01110000
11101011
11011010
10111011
01010100
NAME 6 72

TIL qc
01001000
01011000
11100100
11110010
11010011
11010011
01110010
11100100
NAME 6 73

TIL qd
01101010
01111011
00110101
01010010
00001111
01010011
00110101
01111010
NAME 6 74

TIL qe
10000011
10000000
11011110
11010111
01011101
10101001
11001011
11110001
NAME 6 75

TIL qf
10111011
01010100
01010011
11010101
01011000
00000001
10000101
00100001
NAME 6 76

TIL qg
10000000
00000000
10011101
10010101
10011101
00000010
10011100
10010111
NAME 6 77

TIL qh
00000000
00000000
11011011
01010001
11011011
10100000
10010101
01111001
NAME 6 78

TIL qi
00000000
00000000
01110111
01010101
01110111
10101000
11000111
00101101
NAME 6 79

TIL qj
00001110
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 80

TIL qk
11101111
00000000
00000000
00000000
00000000
00000001
00000001
00000001
NAME 6 81

TIL ql
11011101
00000000
00000000
00000000
00000000
11000000
01000000
11000000
NAME 6 82

TIL qm
11000000
00000000
00000000
00000000
00000000
00011100
00010100
00011100
NAME 6 83

TIL qn
01110111
00001010
01111100
01010100
01111100
00001100
01111001
01011001
NAME 6 84

TIL qo
01111001
10000010
10010001
10010000
10010000
00110000
00111110
00101010
NAME 6 85

TIL qp
01000000
10100101
01000010
00001010
10001011
11100100
10111000
11100100
NAME 6 86

TIL qq
10010011
00001110
00010011
11010100
10011011
01101010
00000110
11110101
NAME 6 87

TIL qr
00110101
01100011
10000010
00010110
01100101
00111000
11000001
01010010
NAME 6 88

TIL qs
01101011
01000110
00010100
00011100
00000011
00011100
00010111
00011100
NAME 6 89

TIL qt
01001000
10010010
00010010
01000100
01000001
10011011
01110100
10011100
NAME 6 90

TIL qu
10100110
10100111
00101000
11110111
01010101
01110111
00000000
00000000
NAME 6 91

TIL qv
10011100
00000010
00011101
00010101
00011101
00000000
00000000
00000000
NAME 6 92

TIL qw
10010010
10100110
11010001
01011111
11010010
11101000
10100000
11100010
NAME 6 93

TIL qx
00001011
11110110
00000111
01001001
00111001
10110001
10001111
00001011
NAME 6 94

TIL qy
00000000
00000000
00000000
00000000
00000000
11011101
01010101
11011101
NAME 6 95

TIL qz
00000000
00000000
00000000
00000000
00000000
11000000
01000000
11000000
NAME 6 96

TIL r0
00000000
00000001
00000001
00000001
00000000
00000001
00000001
00000001
NAME 6 97

TIL r1
00110101
11011000
01101000
11011000
00110101
11000011
01000010
11000011
NAME 6 98

TIL r2
01100000
11011100
10110100
11100111
01101110
10111000
10001010
10010001
NAME 6 99

TIL r3
10010111
10100011
11101010
10101001
11001101
01111101
00111001
01101001
NAME 6 100

TIL r4
01011110
10000010
01100000
10000000
11000010
00101110
01011010
00001110
NAME 6 101

TIL r5
00010101
11101110
10110111
11111011
00011101
01110011
01000011
01101010
NAME 6 102

TIL r6
00011101
11100010
01100000
10100011
11000000
01100010
00110001
01100001
NAME 6 103

TIL r7
00110011
00101011
00001001
01110100
10011100
10100000
11011100
01010100
NAME 6 104

TIL r8
00000010
00011101
00010101
00011101
00000000
00000000
00000000
00000000
NAME 6 105

TIL r9
10100000
11011100
01010100
11011100
00000000
00000000
00000000
00000000
NAME 6 106

TIL ra
00000000
00000000
00000000
00011101
00010101
00011101
00000010
00011100
NAME 6 107

TIL rb
00000000
00000000
00000000
11011100
01010100
11011100
10100000
10011100
NAME 6 108

TIL rc
00011010
11100100
10110001
11101010
00011011
11101111
10100100
11100101
NAME 6 109

TIL rd
00101110
11100001
01001111
01011001
11011001
10000110
11110011
00110011
NAME 6 110

TIL re
00101010
11001001
01110111
00101010
10101010
00011100
01110111
00111110
NAME 6 111

TIL rf
00000000
11000000
01000000
01111011
11101010
00111011
01010100
01010011
NAME 6 112

TIL rg
00000000
00000000
00000000
10000000
10000000
10000000
00000000
10000000
NAME 6 113

TIL rh
00000000
00000011
00000010
00001101
00001011
00001111
00000000
00001101
NAME 6 114

TIL ri
01010011
10000000
11011001
01111000
00101010
10110010
01000101
00001011
NAME 6 115

TIL rj
00010000
00110100
10000100
10111010
11000100
10000011
11100000
00011101
NAME 6 116

TIL rk
11010000
10101110
11101010
00101110
11100000
10100000
00001110
01101010
NAME 6 117

TIL rl
00000101
01110101
01011100
01101001
00001101
01110111
01010101
01110111
NAME 6 118

TIL rm
01000001
01000000
10101100
10000100
10011100
01110000
01010000
01110000
NAME 6 119

TIL rn
11011100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 120

TIL ro
00000000
00000000
00000010
00000000
00000000
00010010
01010101
01110000
NAME 6 121

TIL rp
00000000
00000000
00000000
00000011
00000010
00000011
10111000
10101011
NAME 6 122

TIL rq
00010111
00011100
00000011
10100111
10111110
10100110
01010101
10010010
NAME 6 123

TIL rr
00011010
01000110
11101111
01001000
11111101
00011010
10100001
00010110
NAME 6 124

TIL rs
11100111
10101110
11100000
10001110
00100111
01101011
01101101
00000110
NAME 6 125

TIL rt
01111001
00100010
00110001
01110000
01001001
00100101
00000111
11110110
NAME 6 126

TIL ru
10100010
11100011
00000000
11100011
10100010
11100011
00000000
00000000
NAME 6 127

TIL rv
11101110
10010011
01010100
10111011
10101010
10111011
00000000
00000000
NAME 6 128

TIL rw
10000000
10000000
00000000
10000000
10000000
10000000
00000000
00000000
NAME 6 129

TIL rx
00001011
00001110
00000000
00001101
00001000
00001110
00000011
00000010
NAME 6 130

TIL ry
10010101
10111010
10011110
00101010
00101100
00111110
10000010
10000011
NAME 6 131

TIL rz
01100100
11011101
10110010
01000000
01101100
00000001
01000101
11000011
NAME 6 132

TIL s0
01001110
01110000
11100101
11001101
11010110
10010000
11101001
01100000
NAME 6 133

TIL s1
00000000
00000000
10000000
01000000
11000000
10110111
11010101
00110111
NAME 6 134

TIL s2
00000000
00000000
00000000
00000000
00000000
01110000
01010000
01111110
NAME 6 135

TIL s3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11101110
NAME 6 136

TIL s4
00010001
00010001
00011101
00110010
00100100
01010111
00111101
00101011
NAME 6 137

TIL s5
10111010
01000011
00111000
11101011
00111101
10110110
11101111
01100000
NAME 6 138

TIL s6
11101111
10010011
01010101
10111010
10101011
10111011
00000000
00000000
NAME 6 139

TIL s7
10101000
11000111
10000000
10001001
11110111
11100100
00110101
11101010
NAME 6 140

TIL s8
01101110
10001001
11001001
01100000
01100111
11000101
10000111
11100000
NAME 6 141

TIL s9
00001011
00101101
11001010
10111101
01101010
01010000
01101001
00010010
NAME 6 142

TIL sa
00000000
00000000
00110010
11111110
00110001
11101010
00001101
00010010
NAME 6 143

TIL sb
00000000
00000000
11101110
10101010
01100000
10001101
10000100
00001111
NAME 6 144

TIL sc
00000000
00000000
11100000
10111101
11110101
00011101
01100010
00111100
NAME 6 145

TIL sd
00000011
00000000
00000000
11100111
01000010
11000011
10000001
10100101
NAME 6 146

TIL se
10000110
00000010
00000000
10111011
11010000
10011000
01100000
01000101
NAME 6 147

TIL sf
11100010
10100001
00100101
10111010
10101001
00101000
10111100
01011001
NAME 6 148

TIL sg
10111100
11100101
10011101
11100001
01000110
00000110
11101110
10010011
NAME 6 149

TIL sh
11001010
10110010
01011101
10110010
01001001
00101001
11000010
11101110
NAME 6 150

TIL si
10001010
01111110
11010001
01111110
11010011
00000110
01011001
01001110
NAME 6 151

TIL sj
10101010
11101110
01010000
01001110
10111010
01001110
01010000
11101110
NAME 6 152

TIL sk
00111111
00000101
00000111
01010110
00111101
01111011
00000111
00100110
NAME 6 153

TIL sl
00001111
11011101
00100111
10101000
01110111
01010101
01110100
00000010
NAME 6 154

TIL sm
11101010
00110101
01101100
11101100
11000011
10011010
00010111
11010110
NAME 6 155

TIL sn
11101110
10001010
11010000
11011011
00000000
01001101
00111100
00111000
NAME 6 156

TIL so
11110000
10111001
11101111
01010001
01011101
00001010
10111110
01000000
NAME 6 157

TIL sp
00001101
11101010
00110001
11111110
00110001
00000010
00000011
00000000
NAME 6 158

TIL sq
01010101
01111000
00010000
01011000
10000011
10101010
10111011
00000000
NAME 6 159

TIL sr
01110111
00011100
11100010
10111101
01110101
10011101
10000000
00000000
NAME 6 160

TIL ss
01011010
10100101
10000001
11000011
01000010
11100111
00000000
00000000
NAME 6 161

TIL st
11010010
01100000
00100010
11000101
10100110
10111001
00001110
00001010
NAME 6 162

TIL su
00001110
01111000
10000100
00101100
01011010
01001111
11111110
10110000
NAME 6 163

TIL sv
01010100
00000011
00000010
00000011
11111011
11000010
00000011
00111100
NAME 6 164

TIL sw
00111001
10101110
10111001
10000101
10111011
10101010
10110101
00001010
NAME 6 165

TIL sx
00110010
11100110
00111000
01000000
10111000
10101000
01010110
10101010
NAME 6 166

TIL sy
10101010
11101110
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 167

TIL sz
00001010
00100110
00000000
00010000
00010000
00111000
00010101
01100100
NAME 6 168

TIL t0
00000011
00000000
00000011
11100010
10100011
11100000
00000011
11100010
NAME 6 169

TIL t1
10111011
01010100
10010011
11100011
10001000
01000100
10110010
10110001
NAME 6 170

TIL t2
11111001
00001010
11110111
00000001
10101101
11011100
00100000
00011100
NAME 6 171

TIL t3
11010110
01100001
11010100
10010100
10010100
01110111
01010101
01110111
NAME 6 172

TIL t4
00001110
01011010
10111110
01110000
10000000
01110000
01010000
01110000
NAME 6 173

TIL t5
00000000
00000000
00000000
00000000
01110111
01010101
01110111
00001010
NAME 6 174

TIL t6
00000000
00000000
00000000
00001110
01111010
01011110
01110001
10001110
NAME 6 175

TIL t7
00000111
00000101
00000111
11101110
10101101
11101011
01010111
01001110
NAME 6 176

TIL t8
01110111
01010101
01110111
10101000
00100111
11011101
00100111
10101000
NAME 6 177

TIL t9
00001110
00000000
00000000
11101110
10101010
11101110
00010101
11100100
NAME 6 178

TIL ta
11101001
00111000
00101000
11011011
10100011
11100010
00000011
11100000
NAME 6 179

TIL tb
10000011
00000110
01111011
11101100
10111011
10101010
10111011
00000000
NAME 6 180

TIL tc
10001110
10000001
10001110
00001011
10001110
10000001
10001110
00001010
NAME 6 181

TIL td
11101110
01010000
01001110
10111010
01001110
01010000
11101000
10101111
NAME 6 182

TIL te
11101101
10101011
11101111
00010110
11000011
10001011
01110001
01001010
NAME 6 183

TIL tf
00111011
01100100
00010101
01101110
00101010
01101110
01010100
01000100
NAME 6 184

TIL tg
10100011
11100000
00000000
11100000
10100000
11100000
00000000
00000000
NAME 6 185

TIL th
10101100
00011100
00000010
00011101
00010101
00011101
00000000
00000000
NAME 6 186

TIL ti
01110100
10011100
10100000
11011100
01010100
11011100
00000000
00000000
NAME 6 187

TIL tj
00000011
00000010
00000011
00000000
00000011
00000010
00000011
00000000
NAME 6 188

TIL tk
10111011
10101010
10111011
01010100
10010011
11101110
10010100
01010010
NAME 6 189

TIL tl
11110010
11011101
11110010
00001001
00011010
01111100
01111011
00100010
NAME 6 190

TIL tm
10010101
00000100
11001111
10000010
11100001
01001001
00111000
01101100
NAME 6 191

TIL tn
00011101
10101011
10110111
10011000
00011110
10111000
00101000
01000110
NAME 6 192

TIL to
01110111
01010101
01110111
11011101
01010101
11011101
00101010
11001001
NAME 6 193

TIL tp
10111011
11100100
00010101
00101110
11101010
00101110
00000000
11000000
NAME 6 194

TIL tq
10100000
11100000
00000000
11100000
10100000
11100011
00000010
01110100
NAME 6 195

TIL tr
00111011
00101010
00111011
00000101
00111001
10010100
10010010
11001110
NAME 6 196

TIL ts
10110110
10101000
10111000
01000000
00111000
01101000
10111000
11000000
NAME 6 197

TIL tt
11101001
00000000
00000110
00000101
00000110
00000000
01110000
01010000
NAME 6 198

TIL tu
00100010
01100110
10100010
00010000
01000101
00011001
10101000
10010110
NAME 6 199

TIL tv
01010100
01101110
00011010
00000110
01111100
00000010
01100110
00100110
NAME 6 200

TIL tw
00000000
00000000
00000000
00000000
11101110
10101010
11101110
00010101
NAME 6 201

TIL tx
00000000
00111011
00101010
00111011
11100101
10011001
11001110
00111001
NAME 6 202

TIL ty
00000000
10111000
10101000
10111000
01000000
00111000
11101000
00111000
NAME 6 203

TIL tz
10111110
10101001
10111100
00000010
00000010
00001001
00001110
00001001
NAME 6 204

TIL u0
10000010
01101000
01010100
11001000
01101000
01101100
10100001
10000101
NAME 6 205

TIL u1
00000001
10001010
01001000
11100100
10011100
00000000
01000000
10011100
NAME 6 206

TIL u2
00011100
11000110
11001000
01110110
01010100
11110110
00001110
00001010
NAME 6 207

TIL u3
01110111
11001001
00101010
11011101
01010101
11011101
11101110
10101010
NAME 6 208

TIL u4
01000000
11000000
00000000
11000000
01000000
11000000
00000000
00000000
NAME 6 209

TIL u5
01010101
01110100
00001000
00001100
00000111
00001011
00000010
00001011
NAME 6 210

TIL u6
10101111
00101001
11000101
00010011
10110100
10011011
01001010
00000000
NAME 6 211

TIL u7
10111000
00101000
00111000
10000011
00000010
10000011
10000000
00111011
NAME 6 212

TIL u8
01110001
00001010
01110010
11101000
11010101
10000010
00010000
11100111
NAME 6 213

TIL u9
11011011
10000000
01110000
01010000
11110000
00000000
01110000
00010000
NAME 6 214

TIL ua
00000000
01111110
00111010
01010110
00000000
00000000
00000000
00000000
NAME 6 215

TIL ub
11100100
10111011
11100100
00010101
11101110
10101010
10011001
01010101
NAME 6 216

TIL uc
11100101
10011011
11001010
00111011
11100000
10100000
10010000
01010000
NAME 6 217

TIL ud
01000000
10111000
10101000
10111000
00000000
00000000
00000000
00000000
NAME 6 218

TIL ue
00000000
00000000
00000001
00000001
00000001
00000000
00000001
00000001
NAME 6 219

TIL uf
00000101
00001110
11010110
01011000
11011001
00100010
11000100
01110001
NAME 6 220

TIL ug
11001001
00010111
00100111
10010011
00001011
01101111
01100001
10101111
NAME 6 221

TIL uh
01110100
00111000
01011100
11100100
10000011
00111010
01100011
00100000
NAME 6 222

TIL ui
00001110
00000001
00001110
00001011
10001110
10000001
10001110
00001010
NAME 6 223

TIL uj
11101110
01010000
01001110
10111010
01001110
01010000
11101110
10101010
NAME 6 224

TIL uk
00000111
00001101
00001010
01110111
01010101
01110111
00000000
00000000
NAME 6 225

TIL ul
00101010
10111011
10000101
01001001
01111110
01001001
00000101
00111011
NAME 6 226

TIL um
10101010
10111011
01000001
00111011
11101010
00111010
01000000
10111001
NAME 6 227

TIL un
10011001
01000001
10111101
10000010
01001011
01110001
00101010
11011101
NAME 6 228

TIL uo
00110000
11000000
10000000
11000000
01000000
11000000
00000000
11000000
NAME 6 229

TIL up
01110111
00001010
01110010
01011101
01110010
00001010
01110111
01010101
NAME 6 230

TIL uq
01110000
10000000
01110000
11010000
01110000
10000000
01110000
01010000
NAME 6 231

TIL ur
00000001
00000000
00000001
00000001
00000001
00000000
00000000
00000000
NAME 6 232

TIL us
11001001
00101010
11011101
01010101
11011101
00000000
00000000
00000000
NAME 6 233

TIL ut
11010110
00110101
11110010
01100011
11001010
00000101
00000000
00000100
NAME 6 234

TIL uu
10000011
01000010
00001011
10100000
01010011
11011010
00111011
01000000
NAME 6 235

TIL uv
01100000
00101010
01101110
00010101
01100100
00111011
11110001
11101010
NAME 6 236

TIL uw
00001110
10100000
11100000
00000000
11100000
10100000
11000000
11100000
NAME 6 237

TIL ux
00101010
00111011
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 238

TIL uy
10101001
11001110
01010101
01110111
00001010
00001101
00000111
00001000
NAME 6 239

TIL uz
01010101
10101101
01010000
01110000
10000000
10000000
00000000
10000000
NAME 6 240

TIL v0
01000000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 241

TIL v1
00100000
00000000
00000000
00000000
00000000
00000000
00000010
00000000
NAME 7 1

TIL v2
00000000
00000000
00000000
00000000
00000000
00100000
00000000
00000000
NAME 7 2

TIL v3
00000000
00000000
10000000
00000000
00000000
00000010
00000000
00000000
NAME 7 3

TIL v4
00001000
00000000
01000000
00000000
00000000
00000000
00000000
00000000
NAME 7 4

TIL v5
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01001000
NAME 7 5

TIL v6
00000000
00000000
00000000
00000001
00000000
00000000
00000000
00000000
NAME 7 6

TIL v7
00100000
00000000
00000000
00000000
00000000
00000000
00000000
00010000
NAME 7 7

TIL v8
00000000
00000000
00000000
00000000
00010000
00000000
00000000
00000000
NAME 7 8

TIL v9
00000000
00000000
00000000
00000000
00000000
00000001
00000101
00000111
NAME 7 9

TIL va
00000000
00000000
00000000
00000000
01110000
01111000
10111100
11111110
NAME 7 10

TIL vb
00000000
00000000
00000000
00000000
00000000
00000000
00001000
00000000
NAME 7 11

TIL vc
00000011
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 12

TIL vd
11011010
11101000
11100000
00000000
00000000
00000000
00000000
00000000
NAME 7 13

TIL ve
00000000
00000000
00100000
00000000
00000000
00000000
01000000
00000000
NAME 7 14

TIL vf
00000000
00000000
00000000
00000000
00000000
00010100
00111110
00011100
NAME 7 15

TIL vg
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000
NAME 7 16

TIL vh
00000000
00000000
00000000
00001000
00000000
00000000
00000000
00000000
NAME 7 17

TIL vi
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000100
NAME 7 18

TIL vj
00111110
00010100
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 19

TIL vk
00000000
00000000
00000000
00000000
00000000
00000000
00001111
00011110
NAME 7 20

TIL vl
00000100
10000000
00000000
00000000
00000000
00000000
00000000
00000010
NAME 7 21

TIL vm
00000000
00000000
00000000
00000000
00111000
01111100
11010110
01000011
NAME 7 22

TIL vn
00000000
00000000
10000000
00000000
00000000
00100000
00000000
00000000
NAME 7 23

TIL vo
00000000
00000000
00100000
00000000
00000000
00000000
00000000
00001000
NAME 7 24

TIL vp
00000100
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME 7 25

TIL vq
00010100
00100101
01100110
01101000
01111100
01111111
01110111
01111110
NAME 7 26

TIL vr
10000000
00000000
11000000
11000000
11000000
10000000
00000000
00000000
NAME 7 27

TIL vs
00000011
00000001
00000000
00000000
10000000
00000000
00000000
00000000
NAME 7 28

TIL vt
00110111
10000011
11010110
01111100
00111000
00000000
10000000
00000000
NAME 7 29

TIL vu
00101000
00100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 30

TIL vv
00000000
00000010
00000000
00000000
00000000
00000001
00000000
00000000
NAME 7 31

TIL vw
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100100
NAME 7 32

TIL vx
00000000
00000000
00010000
00000000
00000000
00000000
00000000
00100000
NAME 7 33

TIL vy
00000000
00000000
00000000
00000000
00000000
00000001
00000001
00000000
NAME 7 34

TIL vz
00000000
00111100
01100110
01011011
11000001
10011011
00100001
01101011
NAME 7 35

TIL w0
00000000
00000001
00000000
00100000
10000000
10000000
10000000
00000000
NAME 7 36

TIL w1
00000000
00000000
10000000
00000010
00000000
00000000
00000000
00000000
NAME 7 37

TIL w2
00000000
00000010
00000000
00000000
00001000
00000000
00000000
10000000
NAME 7 38

TIL w3
00000000
00000000
00010000
00000000
00000000
00000000
00011110
00111111
NAME 7 39

TIL w4
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000
NAME 7 40

TIL w5
00111110
00011100
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 41

TIL w6
00000000
00000000
00000100
00000000
00000000
01000000
00000000
00000000
NAME 7 42

TIL w7
00000000
00000000
00000000
01000100
00000000
00000000
00000000
00000000
NAME 7 43

TIL w8
00001000
01000000
00000000
00001000
00000000
00000000
00000000
00000000
NAME 7 44

TIL w9
01101001
01111000
01100100
01100000
00110001
00011111
00001110
00000000
NAME 7 45

TIL wa
10000000
11000000
11000000
11000000
10000000
00000000
00000000
00000000
NAME 7 46

TIL wb
00000000
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 47

TIL wc
00000000
00000110
00000000
00001111
01000000
00111111
00000000
00011111
NAME 7 48

TIL wd
00000000
00000000
00000100
00000000
00000000
10000000
00000000
11000000
NAME 7 49

TIL we
00000000
00000011
00000111
00001111
00011111
00010110
00000101
00000001
NAME 7 50

TIL wf
00000000
10000000
10100000
01101000
11111000
11110000
11100000
11000000
NAME 7 51

TIL wg
00000000
00000000
00000000
00000000
00000010
00000000
00100000
00000000
NAME 7 52

TIL wh
00000000
00001000
00000000
00000001
10000000
00000000
00000000
00000000
NAME 7 53

TIL wi
00000000
00000000
00000000
00000000
00000000
00010000
00000000
00000000
NAME 7 54

TIL wj
00000000
00001111
00000000
00000110
00000000
00000000
00000000
00000000
NAME 7 55

TIL wk
00000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 56

TIL wl
00000000
00000001
00000011
00000011
00000011
00000001
00000000
00000000
NAME 9 1

TIL wm
00000000
10000000
11100000
11000000
11000000
11000000
10000000
00000000
NAME 9 2

TIL wn
00000000
00000111
00001111
00001111
00011111
00111011
00111011
00110111
NAME 9 3

TIL wo
00000000
01110000
11111111
11111111
11111111
11111111
11111111
11011111
NAME 9 4

TIL wp
01111111
00001111
10000001
11110000
11111111
11111111
11101111
11011100
NAME 9 5

TIL wq
11111111
11111111
11111111
00111111
00000011
11000000
11100000
01110000
NAME 9 6

TIL wr
00000000
00000000
00000001
00000011
00000011
00000111
00000111
00000111
NAME 9 7

TIL ws
11111100
11111100
11001000
10000000
10000000
10000000
00000000
00000000
NAME 9 8

TIL wt
00110011
00000000
01000000
01000000
01000000
11000000
00000000
00000000
NAME 9 9

TIL wu
00001111
00011111
00011111
00111111
00111011
01110111
01100111
11100111
NAME 9 10

TIL wv
11111110
11111110
11111100
11111100
11111110
11111110
11111111
11111100
NAME 9 11

TIL ww
00000000
00000000
00000010
00000011
00000111
00000110
00001110
00001100
NAME 9 12

TIL wx
11001111
00001111
00001111
00011111
00011111
00011111
00111111
00111111
NAME 9 13

TIL wy
00000000
00000000
00000010
00011000
00011000
00111011
01111110
11111100
NAME 9 14

TIL wz
00000000
00000000
00000001
00000011
00000011
00000001
00001111
00001111
NAME 9 15

TIL x0
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001110
NAME 9 16

TIL x1
00001100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 9 17

TIL x2
00111111
00111111
01111111
01111111
00111111
00111111
00111111
00011111
NAME 9 18

TIL x3
11111100
11111100
11111110
11111110
11111111
11111111
11111111
11111111
NAME 9 19

TIL x4
00011110
00011111
01111111
01111111
11111110
11111110
11111110
11111100
NAME 9 20

TIL x5
00000000
00000000
00000000
00000001
00000111
00001111
00111111
01111111
NAME 9 21

TIL x6
00010000
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 9 22

TIL x7
00000000
00000000
11000000
11111100
11111111
11111111
11111111
11111111
NAME 9 23

TIL x8
00011100
01110000
11110011
11110111
11000111
11111111
11111111
11111111
NAME 9 24

TIL x9
00011100
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 9 25

TIL xa
00111111
11111001
11111101
11111111
11111111
11111111
11111111
11111111
NAME 9 26

TIL xb
11111100
11111110
00111100
10011100
11111100
11111100
11111100
11011100
NAME 9 27

TIL xc
00000000
00000011
00001111
00011111
00111111
01111111
11111111
11111111
NAME 9 28

TIL xd
11111111
11111111
11111111
11111110
11111111
11111111
11111111
11111111
NAME 9 29

TIL xe
11111111
11111111
11111111
00000000
10000000
11110000
11111110
11111111
NAME 9 30

TIL xf
11111111
11111111
11111111
11001111
00000111
00000001
00000000
11000000
NAME 9 31

TIL xg
11111111
11111111
11111111
11111111
11111111
11111111
10000000
00000000
NAME 9 32

TIL xh
11011100
11000000
11011000
11011000
11111000
11111000
11111000
01111110
NAME 9 33

TIL xi
00000111
00001111
00011111
00111111
01111111
01111111
11111111
11111111
NAME 9 34

TIL xj
11111111
11111111
11111111
11111111
11111111
11111101
11111101
11111111
NAME 9 35

TIL xk
11111111
11111111
11000001
11000000
11000000
10000000
11000000
11001000
NAME 9 36

TIL xl
11111111
11111111
11111111
00111111
00011111
00001111
00001111
00000111
NAME 9 37

TIL xm
11111000
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME 9 38

TIL xn
00000000
00000000
11000000
11110000
11111100
11111100
11111110
11111110
NAME 9 39

TIL xo
00010001
00000000
00000110
00000010
00000000
00000000
00000000
00000000
NAME 9 40

TIL xp
00000011
00000011
00000111
00001111
00011111
00111111
01111111
01111111
NAME 9 41

TIL xq
11000000
11000000
11100000
11111000
11100111
11111000
11111111
11111111
NAME 9 42

TIL xr
00000111
00000111
00000111
00001111
10011111
00011111
11111111
11111111
NAME 9 43

TIL xs
11111111
11111111
11111111
11111110
11111100
11111000
11100000
11000110
NAME 9 44

TIL xt
00000000
00000001
00000011
00000111
00001111
00011111
00111111
00111111
NAME 9 45

TIL xu
10011100
10011110
00011110
00001000
00000000
00000000
00000000
10000000
NAME 9 46

TIL xv
00000000
00000000
00000000
00000001
00000001
00000011
00000011
00000111
NAME 9 47

TIL xw
11000000
11000000
11100000
11110000
11110000
11111000
11111100
11111100
NAME 9 48

TIL xx
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000111
NAME 9 49

TIL xy
00001111
00011111
00111111
01111111
11111111
11111111
11111111
11111111
NAME 9 50

TIL xz
11111111
11111111
11111111
11111111
11111111
11101111
11001111
11011111
NAME 9 51

TIL y0
11111100
11111110
11111110
11111110
11111110
11111111
11111110
11111110
NAME 9 52

TIL y1
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000011
NAME 9 53

TIL y2
00001111
00011111
00111111
00111111
01111111
01111111
11111111
11111111
NAME 9 54

TIL y3
11011111
11111111
11110011
11110001
01110001
11111110
11111110
11111110
NAME 9 55

TIL y4
11111111
11111111
11111111
11111111
11111111
00011111
00011111
01111111
NAME 9 56

TIL y5
11111110
11111110
11111110
11111111
11111111
11111111
11111111
11111111
NAME 9 57

TIL y6
00000001
00000101
00001000
00001000
00001000
00011000
00011000
00011000
NAME 9 58

TIL y7
00011000
00011000
10011000
10011000
10001000
00000000
00100000
00000000
NAME 9 59

TIL y8
11111111
11111111
11111111
11111111
11111111
11111110
11000110
00001110
NAME 9 60

TIL y9
11111110
11111110
11111110
11111110
11111100
01111100
00111000
00011000
NAME 9 61

TIL ya
11111111
11111110
11111111
11111110
11111110
11111110
11111111
11111111
NAME 9 62

TIL yb
00001110
00001110
00001100
00001100
00001100
00011100
00110000
01110000
NAME 9 63

TIL yc
00000000
00000000
00000000
00000000
00000000
11000000
11000000
11000000
NAME 9 64

TIL yd
00000000
01111111
01010000
00000000
00000000
01000000
01101000
01100010
NAME 9 65

TIL ye
00000000
01110000
00111000
00111110
01111010
01110110
00101111
01110111
NAME 9 66

TIL yf
00010000
01001000
01001101
01111111
00111101
01000011
01110001
01110000
NAME 9 67

TIL yg
01111111
01011111
11011111
11011001
11001001
11000001
00001001
00010011
NAME 9 68

TIL yh
01110000
00001001
00001111
01001111
00110101
00010101
01111111
00111110
NAME 9 69

TIL yi
01100001
11000110
10111110
11110110
10110110
11111110
00101111
00010111
NAME 9 70

TIL yj
01110100
00011001
00110100
01000111
00111101
00010111
01011110
01111001
NAME 9 71

TIL yk
00000011
00010111
01011011
11101111
11101101
10010111
10001110
01111111
NAME 9 72

TIL yl
00000000
10000000
10000000
10000000
11100000
01011110
00111111
10101111
NAME 9 73

TIL ym
00000000
00000000
00000000
00000000
00000000
00000000
11000000
01000000
NAME 9 74

TIL yn
00000100
00000100
00000110
00000111
00000101
00000110
00000001
00000001
NAME 9 75

TIL yo
10110110
11110000
11100000
11011000
11111001
11111100
11011111
11011101
NAME 9 76

TIL yp
11111011
10111110
11101100
11111010
11111010
10101100
11111110
10101001
NAME 9 77

TIL yq
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000
NAME 9 78

TIL yr
10011101
10011110
11100111
10101110
10101001
10111111
01011111
11111010
NAME 9 79

TIL ys
01101100
01011100
01110100
11100111
01010011
01100000
11100000
10001011
NAME 9 80

TIL yt
00100000
01111000
11111111
11011101
11101111
01110111
01111011
00111000
NAME 9 81

TIL yu
00000000
00000000
00000000
00000000
00000000
10000000
01111100
10111111
NAME 9 82

TIL yv
01111111
00001111
00000000
00000000
00000000
00000000
00000000
00000000
NAME 9 83

TIL yw
10001000
01111110
11111100
00111100
00000100
00000110
00000111
00000011
NAME 9 84

TIL yx
01111000
00100010
01110000
01111000
11101000
00001111
00000111
10001101
NAME 9 85

TIL yy
11010111
11111110
01011111
00111001
01110010
10010011
10011110
10010111
NAME 9 86

TIL yz
11100000
10100000
01100000
01100000
00010000
00110000
00010000
00110000
NAME 9 87

TIL z0
00000000
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME 9 88

TIL z1
11100111
11101010
11011011
11100011
10100111
01111111
10101110
10011001
NAME 9 89

TIL z2
00011000
10010001
10001011
11111110
11000110
11000110
11000110
11100111
NAME 9 90

TIL z3
10110000
10110000
10110000
10110000
01110000
00010000
01110000
11000000
NAME 9 91

TIL z4
00000001
00000001
00000001
00000001
00000000
00000000
00000000
00000000
NAME 9 92

TIL z5
10111110
11110101
01101111
11111010
00110000
00011100
00001111
00000001
NAME 9 93

TIL z6
11011100
11101110
01001011
11100001
00100000
00010000
00001110
11000000
NAME 9 94

TIL z7
11111110
11011111
11101111
11011010
00111001
00010111
00110001
10101111
NAME 9 95

TIL z8
00000000
11000000
01000000
11100000
10111000
11101000
11011000
10011000
NAME 9 96

TIL z9
01110000
11110101
00001111
00000010
00000011
00000000
00000000
00000000
NAME 9 97

TIL za
11110011
00110110
00111100
10000111
01101010
10010001
10000001
10011001
NAME 9 98

TIL zb
00001000
10001000
01001110
10001010
00010111
11101111
01111001
11111110
NAME 9 99

TIL zc
00000000
00000000
00000000
00000000
11000000
01000000
11000000
11000000
NAME 9 100

TIL zd
10010110
11000011
11101001
01111110
00010111
00011110
00000011
00000011
NAME 9 101

TIL ze
01101100
10110000
11111100
11111100
11011000
00100000
01000010
10001010
NAME 9 102

TIL zf
01111000
00011100
00011111
11010111
10101011
00011111
10111110
00100111
NAME 9 103

TIL zg
00000000
00000000
00000000
11000000
11100000
01100000
00100000
11110000
NAME 9 104

TIL zh
00000010
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME 9 105

TIL zi
11000100
11000001
00111111
00011101
00000111
00000010
00000011
00000011
NAME 9 106

TIL zj
11010011
01111110
10111110
10000101
11010110
01110111
00111011
10111010
NAME 9 107

TIL zk
11011100
11110100
11101100
00100111
00101101
00101111
11100011
11010001
NAME 9 108

TIL zl
11000111
01101110
01110011
01011011
01111000
00001000
00001101
00001110
NAME 9 109

TIL zm
11101001
11110001
11110011
11010100
01011001
10011101
11100111
11011010
NAME 9 110

TIL zn
11000000
01000000
01110000
01111100
11111111
11101111
11111101
10111100
NAME 9 111

TIL zo
00000000
00000000
00000000
00000000
00000000
10000000
10000000
11100000
NAME 9 112

TIL zp
00001011
00001111
00000001
00000001
00000000
00000000
00000000
00000000
NAME 9 113

TIL zq
10101110
01011111
01001111
11111010
01111111
00011101
00001101
00001011
NAME 9 114

TIL zr
00101101
11101101
11001111
00111111
01000011
10100101
01011011
10000111
NAME 9 115

TIL zs
10100000
11100000
01100000
01100000
01111000
10101000
10111000
10011000
NAME 9 116

TIL zt
00001111
00001101
00001100
00001111
00001100
00001101
00001110
00001011
NAME 9 117

TIL zu
11001110
10001100
10000110
10100110
01001111
01000111
11101011
01101111
NAME 9 118

TIL zv
01001000
11001000
00011000
00011100
00001100
00111110
00011011
00111111
NAME 9 119

TIL zw
00001110
00000001
00000001
00000001
00000001
00000001
00000001
00000000
NAME 9 120

TIL zx
01111111
10110111
10110100
10100011
11000011
01100001
11111111
00010111
NAME 9 121

TIL zy
00011111
00011110
00111100
11111110
11110100
00100010
01110110
00011011
NAME 9 122

TIL zz
11000000
11000000
01000000
01000000
01000000
01000000
01000000
11000000
NAME 9 123

SPR A
00010000
00011110
00011011
01011110
01111110
01011000
00111100
01100110
>
00010000
00011110
00011011
01011110
01111110
01011000
00111100
01100110
POS 2 6,2

SPR a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
POS 1 12,2

ITM 0
00000000
00111110
00000100
00001000
00010000
00111110
00000000
00000000
>
00000000
00000000
00011111
00000010
00000100
00001000
00011111
00000000
NAME tea

END 0
You wake up.

END 1
You wake up.

VAR a
42


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
	// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	hex = hex.replace(shorthandRegex, function(m, r, g, b) {
		return r + r + g + g + b + b;
	});

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;
	var effectImage = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var frameRate = 8; // cap the FPS
	var prevStep = -1; // used to avoid running post-process effect constantly

	this.BeginTransition = function(startRoom,startX,startY,endRoom,endX,endY,effectName) {
		// console.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		drawRoom(room[startRoom]);
		var startPalette = getPal( room[startRoom].pal );
		var startImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) ); // TODO : don't use global ctx?
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		drawRoom(room[endRoom]);
		var endPalette = getPal( room[endRoom].pal );
		var endImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) );
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		effectImage = new PostProcessImage( ctx.createImageData(canvas.width,canvas.height) );

		isTransitioning = true;
		transitionTime = 0;
		prevStep = -1;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var transitionDelta = transitionTime / transitionEffects[curEffect].duration;
		var maxStep = Math.floor(frameRate * (transitionEffects[curEffect].duration / 1000));
		var step = Math.floor(transitionDelta * maxStep);

		if (step != prevStep) {
			// console.log("step! " + step + " " + transitionDelta);
			for (var y = 0; y < effectImage.Height; y++) {
				for (var x = 0; x < effectImage.Width; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart,transitionEnd,x,y,(step / maxStep));
					effectImage.SetPixel(x,y,color);
				}
			}
		}
		prevStep = step;

		ctx.putImageData(effectImage.GetData(), 0, 0);

		if (transitionTime >= transitionEffects[curEffect].duration) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			effectImage = null;
			prevStep = -1;
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:255,g:255,b:255,a:255};
			var pixelColorB = delta < 0.5 ? {r:255,g:255,b:255,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:0,g:0,b:0,a:255};
			var pixelColorB = delta < 0.5 ? {r:0,g:0,b:0,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX,pixelY);
		}
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return start.Image.GetPixel(pixelX,pixelY);
				}
			}
			else if (delta <= 0.6)
			{
				return {r:0,g:0,b:0,a:255};
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return end.Image.GetPixel(pixelX,pixelY);
				}
			}
		}
	});

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY >= 0) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY += start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY < start.Image.Height) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY -= start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX >= 0) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX += start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX < start.Image.Width) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX -= start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	function clampLerp(deltaIn, clampDuration) {
		var clampOffset = (1.0 - clampDuration) / 2;
		var deltaOut = Math.min(clampDuration, Math.max(0.0, deltaIn - clampOffset)) / clampDuration;
		return deltaOut;
	}

	// TODO : WIP
	// this.RegisterTransitionEffect("fuzz", {
	// 	showPlayerStart : true,
	// 	showPlayerEnd : true,
	// 	duration : 1500,
	// 	pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
	// 		var curImage = delta <= 0.5 ? start : end;
	// 		var sampleSize = delta <= 0.5 ? (2 + Math.floor(14 * (delta/0.5))) : (16 - Math.floor(14 * ((delta-0.5)/0.5)));

	// 		var palIndex = 0;

	// 		var sampleX = Math.floor(pixelX / sampleSize) * sampleSize;
	// 		var sampleY = Math.floor(pixelY / sampleSize) * sampleSize;

	// 		var frameState = transitionEffects["fuzz"].frameState;

	// 		if (frameState.time != delta) {
	// 			frameState.time = delta;
	// 			frameState.preCalcSampleValues = {};
	// 		}

	// 		if (frameState.preCalcSampleValues[[sampleX,sampleY]]) {
	// 			palIndex = frameState.preCalcSampleValues[[sampleX,sampleY]];
	// 		}
	// 		else {
	// 			var paletteCount = {};
	// 			var foregroundValue = 1.0;
	// 			var backgroundValue = 0.4;
	// 			for (var y = sampleY; y < sampleY + sampleSize; y++) {
	// 				for (var x = sampleX; x < sampleX + sampleSize; x++) {
	// 					var color = curImage.Image.GetPixel(x,y)
	// 					var palIndex = PostProcessUtilities.GetColorPalIndex(color,curImage.Palette);
	// 					if (palIndex != -1) {
	// 						if (paletteCount[palIndex]) {
	// 							paletteCount[palIndex] += (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 						else {
	// 							paletteCount[palIndex] = (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 					}
	// 				}
	// 			}

	// 			var maxCount = 0;
	// 			for (var i in paletteCount) {
	// 				if (paletteCount[i] > maxCount) {
	// 					palIndex = i;
	// 					maxCount = paletteCount[i];
	// 				}
	// 			}

	// 			frameState.preCalcSampleValues[[sampleX,sampleY]] = palIndex;
	// 		}

	// 		return PostProcessUtilities.GetPalColor(curImage.Palette,palIndex);
	// 	},
	// 	frameState : { // ok this is hacky but it's for performance ok
	// 		time : -1,
	// 		preCalcSampleValues : {}
	// 	}
	// });
}; // TransitionManager()


// TODO : extract the scale variable so it can be changed?
var PostProcessUtilities = {
	SamplePixelColor : function(image,x,y) {
		var pixelIndex = (y * scale * image.width * 4) + (x * scale * 4);
		var r = image.data[pixelIndex + 0];
		var g = image.data[pixelIndex + 1];
		var b = image.data[pixelIndex + 2];
		var a = image.data[pixelIndex + 3];
		return { r:r, g:g, b:b, a:a };
	},
	SetPixelColor : function(image,x,y,colorRgba) {
		for (var yDelta = 0; yDelta <= scale; yDelta++) {
			for (var xDelta = 0; xDelta <= scale; xDelta++) {
				var pixelIndex = (((y * scale) + yDelta) * image.width * 4) + (((x * scale) + xDelta) * 4);
				image.data[pixelIndex + 0] = colorRgba.r;
				image.data[pixelIndex + 1] = colorRgba.g;
				image.data[pixelIndex + 2] = colorRgba.b;
				image.data[pixelIndex + 3] = colorRgba.a;
			}
		}
	},
	LerpColor : function(colorA,colorB,t) {
		// TODO: move to color_util.js?
		return {
			r : colorA.r + ((colorB.r - colorA.r) * t),
			g : colorA.g + ((colorB.g - colorA.g) * t),
			b : colorA.b + ((colorB.b - colorA.b) * t),
			a : colorA.a + ((colorB.a - colorA.a) * t),
		};
	},
	GetColorPalIndex : function(colorIn,curPal) {
		var colorIndex = -1;

		for (var i = 0; i < curPal.length; i++) {
			if (colorIn.r == curPal[i][0] && colorIn.g == curPal[i][1] && colorIn.b == curPal[i][2]) {
				colorIndex = i;
			}
		}

		return colorIndex;
	},
	GetPalColor : function(palette,index) {
		return { r: palette[index][0], g: palette[index][1], b: palette[index][2], a: 255 }
	},
	GetCorrespondingColorFromPal : function(colorIn,curPal,otherPal) { // this is kind of hacky!
		var colorIndex = PostProcessUtilities.GetColorPalIndex(colorIn,curPal);

		if (colorIndex >= 0 && colorIndex <= otherPal.length) {
			return PostProcessUtilities.GetPalColor(otherPal,colorIndex);
		}
		else {
			return colorIn;
		}
	},
};

var PostProcessImage = function(imageData) {
	this.Width = imageData.width / scale;
	this.Height = imageData.height / scale;

	this.GetPixel = function(x,y) {
		return PostProcessUtilities.SamplePixelColor(imageData,x,y);
	};

	this.SetPixel = function(x,y,colorRgba) {
		PostProcessUtilities.SetPixelColor(imageData,x,y,colorRgba);
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;
	this.Palette = palette;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
/*
TODO:
- untangle local & external resource use in font manager (still more to do here)
*/

function FontManager(useExternalResources) {

if (useExternalResources === undefined || useExternalResources === null) {
	useExternalResources = false;
}

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data that is part of the local game data
var localResources = {};

// place to store font data fetched from a server (only used in editor)
var externalResources = null;
if (useExternalResources) {
	externalResources = new ResourceLoader();// NOTE : this class doesn't exist in exported game
}

this.LoadResources = function(filenames, onLoadAll) {
	if (!useExternalResources)
		return;

	// TODO : is this being called too many times?
	var onLoad = function() {
		var count = externalResources.getResourceLoadedCount();

		if (count >= filenames.length && onLoadAll != null) {
			onLoadAll();
		}
	}

	for (var i = 0; i < filenames.length; i++) {
		externalResources.load("bitsyfont", filenames[i], onLoad);
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	if (useExternalResources) {
		externalResources.set(filename, fontdata);
	}
	else {
		localResources[filename] = fontdata;
	}
}

this.ContainsResource = function(filename) {
	if (useExternalResources) {
		return externalResources.contains(filename);
	}
	else {
		return localResources[filename] != null;
	}
}

function GetData(fontName) {
	if (useExternalResources) {
		return externalResources.get(fontName + fontExtension);
	}
	else {
		return localResources[fontName + fontExtension];
	}
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};
	var invalidCharData = {};

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function parseFont(fontData) {
		if (fontData == null)
			return;

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = {
						width: width,
						height: height,
						offset: {
							x: 0,
							y: 0
						},
						spacing: width,
						data: []
					};
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// init invalid character box
		invalidCharData = {
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width, // TODO : name?
			data: []
		};
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse( scriptStr );
		env.SetScript( scriptName, script );
	}
	this.Run = function(scriptName, exitHandler) { // Runs pre-compiled script
		// console.log("RUN");
		// console.log(env.GetScript( scriptName ));
		env.GetScript( scriptName )
			.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );

		// console.log("SERIALIZE!!!!");
		// console.log( env.GetScript( scriptName ).Serialize() );
	}
	this.Interpret = function(scriptStr, exitHandler) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var script = parser.Parse( scriptStr );
		script.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr) { // parses a script but doesn't save it
		return parser.Parse( scriptStr );
	}
	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		scriptTree.Eval( env, function(result) { OnScriptReturn(result, exitHandler); } );
	}

	function OnScriptReturn(result, exitHandler) {
		if (isReturnObject(result)) {
			result = result.result; // pull out the contained result
		}

		// console.log("RESULT " + result);

		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression( expStr );
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	this.DebugVisualizeScriptTree = function(scriptName) {
		var printVisitor = {
			Visit : function(node,depth) {
				console.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		env.GetScript( scriptName ).VisitAll( printVisitor );
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if(doIndentFirstLine === undefined) doIndentFirstLine = true;
		var block = new BlockNode( BlockMode.Dialog, doIndentFirstLine );
		for(var i = 0; i < children.length; i++) {
			block.AddChild( children[i] );
		}
		return block;
	}

	this.ChangeSequenceType = function(oldSequence,type) {
		if(type === "sequence") {
			return new SequenceNode( oldSequence.options );
		}
		else if(type === "cycle") {
			return new CycleNode( oldSequence.options );
		}
		else if(type === "shuffle") {
			return new ShuffleNode( oldSequence.options );
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var option2 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new BlockNode( BlockMode.Code );
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new BlockNode( BlockMode.Dialog );
		var result2 = new BlockNode( BlockMode.Dialog );

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

// TODO : vNext
// function returnFunc(environment,parameters,onReturn) {
// 	var ret = { isReturn: true, result: null };
// 	if (parameters.length > 0 && parameters[0] != undefined && parameters[0] != null) {
// 		ret.result = parameters[0];
// 	}
// 	onReturn(ret);
// }

// TODO : vNext
// // TODO : this is kind of hacky
// // - needs to work with names too
// function changeAvatarFunc(environment,parameters,onReturn) {
// 	if( parameters[0] != undefined && parameters[0] != null ) {
// 		sprite["A"].drw = "SPR_" + parameters[0];
// 	}
// 	onReturn(null);
// }

function printFunc(environment,parameters,onReturn) {
	// console.log("PRINT FUNC");
	// console.log(parameters);
	if( parameters[0] != undefined && parameters[0] != null ) {
		// console.log(parameters[0]);
		// console.log(parameters[0].toString());
		// var textStr = parameters[0].toString();
		var textStr = "" + parameters[0];
		// console.log(textStr);
		var onFinishHandler = function() {
			// console.log("FINISHED PRINTING ---- SCRIPT");
			onReturn(null);
		}; // called when dialog is finished printing
		environment.GetDialogBuffer().AddText( textStr, onFinishHandler );
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment,parameters,onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	onReturn(null);
}

function printDrawingFunc(environment,parameters,onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing( drawingId, function() {
		onReturn(null);
	});
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get( fontName );
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var itemCount = player().inventory[itemId] ? player().inventory[itemId] : 0; // TODO : ultimately the environment should include a reference to the game state
	// console.log("ITEM FUNC " + itemId + " " + itemCount);
	onReturn(itemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("print", printFunc);
	functionMap.set("say", printFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);
	functionMap.set("printSprite", printSpriteFunc);
	functionMap.set("printTile", printTileFunc);
	functionMap.set("printItem", printItemFunc);
	functionMap.set("debugOnlyPrintFont", printFontFunc); // DEBUG ONLY

	// TODO : vNext
	// functionMap.set("changeAvatar", changeAvatarFunc);
	// functionMap.set("return", returnFunc);

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn) {
		// console.log(functionMap);
		// console.log(name);
		functionMap.get( name )( this, parameters, onReturn );
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler)
			onVariableChangeHandler(name);
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler)
				onVariableChangeHandler(name);
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];
	this.AddChild = function(node) {
		this.children.push( node );
		node.parent = this;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.children.length; i++ ) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};
}

function isReturnObject(val) {
	return typeof val === "object" && val != null
				&& val.isReturn != undefined && val.isReturn != null
				&& val.isReturn;
}

var BlockMode = {
	Code : "code",
	Dialog : "dialog"
};

var BlockNode = function(mode, doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "block";
	this.mode = mode;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if( this.onEnter != null ) {
			this.onEnter();
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children,done) {
			if (i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval( environment, function(val) {
					// console.log("<< CHILD " + i);

					if (isReturnObject(val)) { // early return
						lastVal = val;
						done();
					}
					else {
						lastVal = val;
						i++;
						evalChildren(children,done);
					}
				} );
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren( this.children, function() {
			if( self.onExit != null ) {
				self.onExit();
			}
			onReturn(lastVal);
		} );
	}

	if(doIndentFirstLine === undefined) doIndentFirstLine = true; // This is just for serialization

	this.Serialize = function(depth) {
		if(depth === undefined) depth = 0;

		// console.log("SERIALIZE BLOCK!!!");
		// console.log(depth);
		// console.log(doIndentFirstLine);

		var str = "";
		var lastNode = null;
		if (this.mode === BlockMode.Code) str += "{"; // todo: increase scope of Sym?
		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			if(curNode.type === "block" && lastNode && lastNode.type === "block" && !isBlockWithNoNewline(curNode) && !isBlockWithNoNewline(lastNode))
				str += "\n";

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			if(this.mode === BlockMode.Dialog && (shouldIndentFirstLine || shouldIndentAfterLinebreak))
				str += leadingWhitespace(depth);
			str += curNode.Serialize(depth);
			lastNode = curNode;
		}
		if (this.mode === BlockMode.Code) str += "}";
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

function isBlockWithNoNewline(node) {
	return isTextEffectBlock(node) || isMultilineListBlock(node);
}

function isTextEffectBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			if(func.name === "clr1" || func.name === "clr2" || func.name === "clr3" || func.name === "wvy" || func.name === "shk" || func.name === "rbw") {
				return true;
			}
		}
	}
	return false;
}

function isMultilineListBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0) {
			var child = node.children[0];
			if(child.type === "sequence" || child.type === "cycle" || child.type === "shuffle" || child.type === "if") {
				return true;
			}
		}
	}
	return false;
}

var FuncNode = function(name,arguments) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.arguments = arguments;

	this.Eval = function(environment,onReturn) {

		if( this.onEnter != null ) this.onEnter();

		// console.log("FUNC");
		// console.log(this.arguments);
		var argumentValues = [];
		var i = 0;
		function evalArgs(arguments,done) {
			if(i < arguments.length) {
				// Evaluate each argument
				arguments[i].Eval( environment, function(val) {
					argumentValues.push( val );
					i++;
					evalArgs(arguments,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this; // hack to deal with scope
		evalArgs( this.arguments, function() {
			// Then evaluate the function
			// console.log("ARGS");
			// console.log(argumentValues);

			if( self.onExit != null ) self.onExit();

			environment.EvalFunction( self.name, argumentValues, onReturn );
		} );
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.mode && this.parent.mode === BlockMode.Dialog;
		if(isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.arguments[0].value; // first argument should be the text of the {print} func
		}
		else if(isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.arguments.length; i++) {
				str += " ";
				str += this.arguments[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name;
	};
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if(this.value === null)
			return str;

		if(typeof this.value === "string") str += '"';
		str += this.value;
		if(typeof this.value === "string") str += '"';

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.value;
	};
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name;
	};
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right,
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if(!isNegativeNumber) {
			var str = "";
			str += this.left.Serialize(depth);
			str += " " + this.operator + " ";
			str += this.right.Serialize(depth);
			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator;
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.options.length; i++) {
			// console.log("SERIALIZE SEQUENCE ");
			// console.log(depth);
			str += leadingWhitespace(depth + 1) + Sym.List + " " + this.options[i].Serialize(depth + 2) + "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.options.length; i++ ) {
			this.options[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type;
	};
}

var SequenceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "sequence";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("SEQUENCE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
	}
}

var CycleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "cycle";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("CYCLE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
		else
			index = 0;
	}
}

var ShuffleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "shuffle";
	this.options = options;

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while(optionsUnshuffled.length > 0) {
			var i = Math.floor( Math.random() * optionsUnshuffled.length );
			optionsShuffled.push( optionsUnshuffled.splice(i,1)[0] );
		}
	}
	shuffle(this.options);

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// OLD RANDOM VERSION
		// var index = Math.floor(Math.random() * this.options.length);
		// this.options[index].Eval( environment, onReturn );

		optionsShuffled[index].Eval( environment, onReturn );

		index++;
		if (index >= this.options.length) {
			shuffle(this.options);
			index = 0;
		}
	}
}

var IfNode = function(conditions, results, isSingleLine) {
	Object.assign( this, new TreeRelationship() );
	this.type = "if";
	this.conditions = conditions;
	this.results = results;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		var self = this;
		function TestCondition() {
			// console.log("EVAL " + i);
			self.conditions[i].Eval(environment, function(val) {
				// console.log(val);
				if(val == true) {
					self.results[i].Eval(environment, onReturn);
				}
				else if(i+1 < self.conditions.length) {
					i++;
					TestCondition(); // test next condition
				}
				else {
					onReturn(null); // out of conditions and none were true
				}
			});
		};
		TestCondition();
	}

	if(isSingleLine === undefined) isSingleLine = false; // This is just for serialization

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			str += this.conditions[0].Serialize() + " ? " + this.results[0].Serialize();
			if(this.conditions.length > 1 && this.conditions[1].type === "else")
				str += " : " + this.results[1].Serialize();
		}
		else {
			str += "\n";
			for (var i = 0; i < this.conditions.length; i++) {
				str += leadingWhitespace(depth + 1) + Sym.List + " " + this.conditions[i].Serialize(depth) + " ?\n";
				str += this.results[i].Serialize(depth + 2) + "\n";
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		for( var i = 0; i < this.conditions.length; i++ ) {
			this.conditions[i].VisitAll( visitor, depth + 1 );
		}
		for( var i = 0; i < this.results.length; i++ ) {
			this.results[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "else";

	this.Eval = function(environment,onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return "else";
	}

	this.ToString = function() {
		return this.type + " " + this.mode;
	};
}

var Sym = {
	// DialogOpen : "/\"",
	// DialogClose : "\"/",
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"'
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr) {
		// console.log("NEW PARSE!!!!!!");

		// TODO : make this work for single-line, no dialog block scripts

		var state = new ParserState( new BlockNode(BlockMode.Dialog), scriptStr );

		if( state.MatchAhead(Sym.DialogOpen) ) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
			state = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
			state = ParseDialog( state );
		}
		// else if( state.MatchAhead(Sym.CodeOpen) ) { // NOTE: This causes problems when you lead with a code block
		// 	// code-block: should this ever happen?
		// 	state = ParseCodeBlock( state );
		// }
		else {
			// single-line dialog block
			state = ParseDialog( state );
		}

		// console.log( state.rootNode );
		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for(var j = 0; j < str.length; j++) {
				if( i + j >= sourceStr.length )
					return false;
				else if( str[j] != sourceStr[i+j] )
					return false;
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while(j < sourceStr.length && end.indexOf( sourceStr[j] ) == -1 ) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function( open, close ) {
			var startIndex = i;

			var matchCount = 0;
			if( this.MatchAhead( open ) ) {
				matchCount++;
				this.Step( open.length );
			}

			while( matchCount > 0 && !this.Done() ) {
				if( this.MatchAhead( close ) ) {
					matchCount--;
					this.Step( close.length );
				}
				else if( this.MatchAhead( open ) ) {
					matchCount++;
					this.Step( open.length );
				}
				else {
					this.Step();
				}
			}

			// console.log("!!! " + startIndex + " " + i);

			return sourceStr.slice( startIndex + open.length, i - close.length );
		}
		this.Print = function() { console.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	function ParseDialog(state) {
		// console.log("PARSE DIALOG");
		state.Print();

		// for linebreak logic: add linebreaks after lines with dialog or empty lines (if it's not the very first line)
		var hasBlock = false;
		var hasDialog = false;
		var isFirstLine = true;

		// console.log("---- PARSE DIALOG ----");

		var text = "";
		var addTextNode = function() {
			// console.log("TEXT " + text.length);
			if (text.length > 0) {
				// console.log("TEXT " + text);
				// console.log("text!!");
				// console.log([text]);

				state.curNode.AddChild( new FuncNode( "print", [new LiteralNode(text)] ) );
				text = "";

				hasDialog = true;
			}
		}

		while ( !state.Done() ) {

			if( state.MatchAhead(Sym.CodeOpen) ) {
				addTextNode();
				state = ParseCodeBlock( state );

				// console.log("CODE");

				var len = state.curNode.children.length;
				if(len > 0 && state.curNode.children[len-1].type === "block") {
					var block = state.curNode.children[len-1];
					if(isMultilineListBlock(block))
						hasDialog = true; // hack to get correct newline behavior for multiline blocks
				}

				hasBlock = true;
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	addTextNode();
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)

			// 	hasBlock = true;
			// }
			else {
				if ( state.MatchAhead(Sym.Linebreak) ) {
					addTextNode();

					/*
					NOTES:
					linebreaks SHOULD happen on
					- lines with text (including the first or last line)
					- empty lines (that are NOT the first or last line)
					linebreaks should NOT happen on
					- lines with only CODE blocks
					- empty FIRST or LAST lines

					also, apparently:
					- NEVER line break on the last line
					*/
					var isLastLine = (state.Index() + 1) == state.Count();
					// console.log("block " + hasBlock);
					// console.log("dialog " + hasDialog);
					var isEmptyLine = !hasBlock && !hasDialog;
					// console.log("empty " + isEmptyLine);
					var isValidEmptyLine = isEmptyLine && !(isFirstLine || isLastLine);
					// console.log("valid empty " + isValidEmptyLine);
					var shouldAddLinebreak = (hasDialog || isValidEmptyLine) && !isLastLine; // last clause is a hack (but it works - why?)
					// console.log("LINEBREAK? " + shouldAddLinebreak);
					if( shouldAddLinebreak ) {
						// console.log("NEWLINE");
						// console.log("empty? " + isEmptyLine);
						// console.log("dialog? " + hasDialog);
						state.curNode.AddChild( new FuncNode( "br", [] ) ); // use function or character?
					}

					// linebreak logic
					isFirstLine = false;
					hasBlock = false;
					hasDialog = false;

					text = "";
				}
				else {
					text += state.Char();
				}
				state.Step();
			}

		}
		addTextNode();

		// console.log("---- PARSE DIALOG ----");

		// console.log(state);
		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	function ParseIf(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var isNewline = true;
		var isConditionDone = false;
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				curIndex++;
				isConditionDone = false;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}
			else if(curIndex > -1) {
				if(!isConditionDone) {
					if(state.Char() === "?" || state.Char() === "\n") { // TODO: use Sym
						// end of condition
						isConditionDone = true;
					}
					else {
						// read in condition
						conditionStrings[curIndex] += state.Char();
					}
				}
				else {
					// read in result
					if(!isSkippableWhitespace)
						resultStrings[curIndex] += state.Char();
				}
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			state.Step();
		}

		// console.log("PARSE IF:");
		// console.log(conditionStrings);
		// console.log(resultStrings);

		var conditions = [];
		for(var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if(str === "else") {
				conditions.push( new ElseNode() );
			}
			else {
				var exp = CreateExpression( str );
				conditions.push( exp );
			}
		}

		var results = [];
		for(var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			results.push( dialogBlock );
		}

		state.curNode.AddChild( new IfNode( conditions, results ) );

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	// TODO: don't forget about eating whitespace
	function ParseSequence(state, sequenceType) {
		// console.log("SEQUENCE " + sequenceType);
		state.Print();

		var isNewline = false;
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				// console.log("found next list item");
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}
			else if(curItemIndex > -1) {
				if(!isSkippableWhitespace)
					itemStrings[curItemIndex] += state.Char();
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			// console.log(state.Char());
			state.Step();
		}
		// console.log(itemStrings);
		// console.log("SEQUENCE DONE");

		var options = [];
		for(var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState( new BlockNode( BlockMode.Dialog, false /* doIndentFirstLine */ ), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			options.push( dialogBlock );
		}

		// console.log(options);

		if(sequenceType === "sequence")
			state.curNode.AddChild( new SequenceNode( options ) );
		else if(sequenceType === "cycle")
			state.curNode.AddChild( new CycleNode( options ) );
		else if(sequenceType === "shuffle")
			state.curNode.AddChild( new ShuffleNode( options ) );

		return state;
	}

	function ParseFunction(state, funcName) {
		console.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState( new BlockNode(BlockMode.Code), state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose ) );
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState( new BlockNode( BlockMode.Code ), codeStr );
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	var setSymbol = "=";
	var ifSymbol = "?";
	var elseSymbol = ":";
	var operatorSymbols = ["==", ">", "<", ">=", "<=", "-", "+", "/", "*"]; // operators need to be in reverse order of precedence
	function CreateExpression(expStr) {
		console.log("CREATE EXPRESSION --- " + expStr);

		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(setSymbol);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = setSymbol;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+setSymbol.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(ifSymbol);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = ifSymbol;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+ifSymbol.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(elseSymbol); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+elseSymbol.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < operatorSymbols.length); i++ ) {
			var opSym = operatorSymbols[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var nonWhitespaceCount = 0;

		while (!tempState.Done()) {
			if( IsWhitespace(tempState.Char()) ) {
				tempState.Step(); // consume whitespace
			}
			else if( tempState.MatchAhead(Sym.CodeOpen) ) {
				tempState.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
			}
			else {
				nonWhitespaceCount++;
				tempState.Step();
			}
		}

		var isExpression = nonWhitespaceCount > 0;
		return isExpression;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression( line );
		// console.log(exp);
		state.curNode.AddChild( exp );
		state.Step( line.length );
		return state;
	}

	function ParseCode(state) {
		console.log("PARSE CODE --- " + state.Source());

		// skip leading whitespace
		while (IsWhitespace(state.Char())) {
			state.Step();
		}

		if( state.Char() === Sym.List && (state.Peak([]).indexOf("?") > -1) ) { // TODO : symbols? matchahead?
			// console.log("PEAK IF " + state.Peak( ["?"] ));
			state = ParseIf( state );
		}
		else if( environment.HasFunction( state.Peak( [" "] ) ) ) { // TODO --- what about newlines???
			var funcName = state.Peak( [" "] );
			state.Step( funcName.length );
			state = ParseFunction( state, funcName );
		}
		else if( IsSequence( state.Peak( [" ", Sym.Linebreak] ) ) ) {
			var sequenceType = state.Peak( [" ", Sym.Linebreak] );
			state.Step( sequenceType.length );
			state = ParseSequence( state, sequenceType );
		}
		else if (IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			// multi-line code block
			while (!state.Done()) {
				if( state.MatchAhead(Sym.CodeOpen) ) {
					state = ParseCodeBlock( state );
				}
				else {
					state.Step();
				}
			}
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );

		// console.log("PARSE CODE");
		// console.log(codeStr);

		var codeState = new ParserState( new BlockNode(BlockMode.Code), codeStr );
		codeState = ParseCode( codeState );

		state.curNode.AddChild( codeState.rootNode );

		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;

		//create new image none exists
		if(textboxInfo.img == null)
			textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

		// fill text box with black
		for (var i=0;i<textboxInfo.img.data.length;i+=4)
		{
			textboxInfo.img.data[i+0]=0;
			textboxInfo.img.data[i+1]=0;
			textboxInfo.img.data[i+2]=0;
			textboxInfo.img.data[i+3]=255;
		}
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

		var debug_r = Math.random() * 255;

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {

				var i = (y * char.width) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}
				}
				// else {
				// 	// DEBUG

				// 	//scaling nonsense
				// 	for (var sy = 0; sy < text_scale; sy++) {
				// 		for (var sx = 0; sx < text_scale; sx++) {
				// 			var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
				// 			textboxInfo.img.data[pxl+0] = debug_r;
				// 			textboxInfo.img.data[pxl+1] = 0;
				// 			textboxInfo.img.data[pxl+2] = 0;
				// 			textboxInfo.img.data[pxl+3] = 255;
				// 		}
				// 	}
				// }

			}
		}

		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer,dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar( this.DrawChar );

		if( buffer.CanContinue() )
			this.DrawNextArrow();

		this.DrawTextbox();

		if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
			onPageFinish();
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// console.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		// console.log("DO NEXT CHAR");

		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;

			// console.log("WAITING FOR INPUT");
		}

		// console.log(this.CurChar());
		if(this.CurChar() != null)
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	this.Continue = function() {
		console.log("CONTINUE");
		if (pageIndex + 1 < this.CurPageCount()) {
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// console.log("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetImageSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddDrawing = function(drawingId, onFinishHandler) {
		// console.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects)
		drawingChar.SetPrintHandler( onFinishHandler );

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0)
		{
			//stay on same row
			curRowArr.push( drawingChar );
		}
		else if (curRowIndex == 0)
		{
			//start next row
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer[ curPageIndex ].push( [] );
			curRowIndex++;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}
		else {
			//start next page
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer.push( [] );
			curPageIndex++;
			buffer[ curPageIndex ].push( [] );
			curRowIndex = 0;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr,onFinishHandler) {
		// console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth( wordWithPrecedingSpace );

			var rowLength = GetCharArrayWidth(curRowArr);

			if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, activeTextEffects );
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer[ curPageIndex ].push( [] );
				curRowIndex++;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
			else {
				//start next page
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer.push( [] );
				curPageIndex++;
				buffer[ curPageIndex ].push( [] );
				curRowIndex = 0;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[ buffer.length-1 ];
		var lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length == 0 )
			lastPage.splice( lastPage.length-1, 1 );
		if( lastPage.length == 0 )
			buffer.splice( buffer.length-1, 1 );

		//finish up
		lastPage = buffer[ buffer.length-1 ];
		lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length > 0 ) {
			var lastChar = lastRow[ lastRow.length-1 ];
			lastChar.SetPrintHandler( onFinishHandler );
		}

		console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[ buffer.length-1 ];
		if( lastPage.length <= 1 ) {
			console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push( [] );
		}
		else {
			// add new page
			buffer.push( [[]] );
		}
		console.log(buffer);

		isActive = true;
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		// console.log("RAINBOW!!!");
		// console.log(char);
		// console.log(char.color);
		// console.log(char.col);

		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		// console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
	source: {},
	render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
	palettes = paletteObj;

	// TODO : should this really clear out the render cache?
	imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
	var palette = palettes[paletteId];

	if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
		colorIndex = 0;
	}

	var color = palette.colors[colorIndex];

	return {
		r : color[0],
		g : color[1],
		b : color[2]
	};
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
	// debugRenderCount++;
	// console.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;
	var imgSrc = imageStore.source[ drawing.drw ];

	// initialize render cache entry
	if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
		imageStore.render[drwId] = {};
	}

	if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
		imageStore.render[drwId][pal] = {};
	}

	// create array of ImageData frames
	imageStore.render[drwId][pal][colStr] = [];

	for (var i = 0; i < imgSrc.length; i++) {
		var frameSrc = imgSrc[i];
		var frameData = imageDataFromImageSource( frameSrc, pal, col );
		imageStore.render[drwId][pal][colStr].push(frameData);
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = context.createImageData(tilesize*scale,tilesize*scale);

	var backgroundColor = getPaletteColor(pal,0);
	var foregroundColor = getPaletteColor(pal,col);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if ( px === 1 ) {
						img.data[pxl + 0] = foregroundColor.r;
						img.data[pxl + 1] = foregroundColor.g;
						img.data[pxl + 2] = foregroundColor.b;
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = backgroundColor.r;
						img.data[pxl + 1] = backgroundColor.g;
						img.data[pxl + 2] = backgroundColor.b;
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}

	return img;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;

	if (undefinedOrNull(imageStore.render[drwId]) ||
		undefinedOrNull(imageStore.render[drwId][pal]) ||
		undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
			return false;
	}
	else {
		return true;
	}
}

function getImageSet(drawing, paletteId) {
	return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
	if (!isImageRendered(drawing, paletteId)) {
		renderImage(drawing, paletteId);
	}

	return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
	imageStore.source[drawingId] = imageSourceData;
	imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
	return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
	context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = {
	"0" : [[0,0,0],[255,0,0],[255,255,255]] //start off with a default palette (can be overriden)
};
var ending = {};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	/*dialog : new Map()*/ // TODO
	/*ending : new Map()*/ // TODO
};
function updateNamesFromCurData() {
	names.room = new Map();
	for(id in room) {
		if(room[id].name != undefined && room[id].name != null) {
			names.room.set( room[id].name, id );
		}
	}
	names.tile = new Map();
	for(id in tile) {
		if(tile[id].name != undefined && tile[id].name != null) {
			names.tile.set( tile[id].name, id );
		}
	}
	names.sprite = new Map();
	for(id in sprite) {
		if(sprite[id].name != undefined && sprite[id].name != null) {
			names.sprite.set( sprite[id].name, id );
		}
	}
	names.item = new Map();
	for(id in item) {
		if(item[id].name != undefined && item[id].name != null) {
			names.item.set( item[id].name, id );
		}
	}
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 6, // major changes
	minor: 0 // smaller changes
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	title = "";
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette (can be overriden)
		"0" : {
			name : null,
			colors : [[0,0,0],[255,0,0],[255,255,255]]
		}
	};
	ending = {};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map()
	};

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
	renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(game_data);

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	// setInterval(updateLoadingScreen, 300); // hack test

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) return; //can't reset if we don't have the game data
	stopGame();
	clearGameData();
	load_game(curGameData);
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart);
		canvas.addEventListener('touchmove', input.ontouchmove);
		canvas.addEventListener('touchend', input.ontouchend);
	}
	else {
		document.addEventListener('touchstart', input.ontouchstart);
		document.addEventListener('touchmove', input.ontouchmove);
		document.addEventListener('touchend', input.ontouchend);
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update,-1);

	console.log("TITLE ??? " + startWithTitle);
	if(startWithTitle) // used by editor
		startNarrating(title);
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

// TODO: this is likely broken
function breadthFirstSearch(map, from, to) {
	from.trail = [];
	var visited = [];
	var queue = [from];
	visited.push( posToString(from) );

	//console.log( "~ bfs ~");
	//console.log( posToString(from) + " to " + posToString(to) );

	while ( queue.length > 0 ) {

		//grab pos from queue and mark as visited
		var curPos = queue.shift();

		//console.log( posToString(curPos) );
		//console.log( ".. " + pathToString(curPos.trail) );
		//console.log( visited );

		if (curPos.x == to.x && curPos.y == to.y) {
			//found a path!
			var path = curPos.trail.splice(0);
			path.push( curPos );
			return path;
		}

		//look at neighbors
		neighbors(curPos).forEach( function(n) {
			var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
			if (inBounds) {
				var noCollision = map[n.y][n.x] <= 0;
				var notVisited = visited.indexOf( posToString(n) ) == -1;
				if (noCollision && notVisited) {
					n.trail = curPos.trail.slice();
					n.trail.push(curPos);
					queue.push( n );
					visited.push( posToString(n) );
				}
			}
		});

	}

	return []; // no path found
}

function posToString(pos) {
	return pos.x + "," + pos.y;
}

function pathToString(path) {
	var s = "";
	for (i in path) {
		s += posToString(path[i]) + " ";
	}
	return s;
}

function neighbors(pos) {
	var neighborList = [];
	neighborList.push( {x:pos.x+1, y:pos.y+0} );
	neighborList.push( {x:pos.x-1, y:pos.y+0} );
	neighborList.push( {x:pos.x+0, y:pos.y+1} );
	neighborList.push( {x:pos.x+0, y:pos.y-1} );
	return neighborList;
}

function collisionMap(roomId) {
	var map = [
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	];

	for (r in room[roomId].tilemap) {
		var row = room[roomId].tilemap[r];
		for (var c = 0; c < row.length; c++) {
			if (room[roomId].walls.indexOf( row[x] ) != -1) {
				map[r][c] = 1;
			}
		}
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			map[spr.y][spr.x] = 2;
		}
	}

	return map;
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		document.removeEventListener('touchstart', input.ontouchstart);
		document.removeEventListener('touchmove', input.ontouchmove);
		document.removeEventListener('touchend', input.ontouchend);
	}

	window.onblur = null;

	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
	// TODO : in progress
	ctx.fillStyle = "rgb(0,0,0)";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	loadingAnimation();
	drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (!transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom( room[curRoom] ); // draw world if game has begun
		}
		else {
			//make sure to still clear screen
			ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
			ctx.fillRect(0,0,canvas.width,canvas.height);
		}

		// if (isDialogMode) { // dialog mode
		if(dialogBuffer.IsActive()) {
			dialogRenderer.Draw( dialogBuffer, deltaTime );
			dialogBuffer.Update( deltaTime );
		}
		else if (!isEnding) {
			moveSprites(); // TODO : I probably need to remove this..
		}

		// keep moving avatar if player holds down button
		if( !dialogBuffer.IsActive() && !isEnding )
		{
			if( curPlayerDirection != Direction.None ) {
				playerHoldToMoveTimer -= deltaTime;

				if( playerHoldToMoveTimer <= 0 )
				{
					movePlayer( curPlayerDirection );
					playerHoldToMoveTimer = 150;
				}
			}
		}
	}

	prevTime = curTime;

	//for gif recording
	if (didPlayerMoveThisFrame && onPlayerMoved != null) {
		onPlayerMoved();
	}
	didPlayerMoveThisFrame = false;

	/* hacky replacement */
	if (onDialogUpdate != null) {
		dialogRenderer.SetPageFinishHandler( onDialogUpdate );
	}

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateInput() {
	if( dialogBuffer.IsActive() ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					input.ignoreHeldKeys();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if ( isEnding ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
			curPlayerDirection = Direction.Down;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 500;
		}
	}
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
	moveCounter += deltaTime;

	if (moveCounter >= moveTime) {

		for (id in sprite) {
			var spr = sprite[id];
			if (spr.walkingPath.length > 0) {
				//move sprite
				var nextPos = spr.walkingPath.shift();
				spr.x = nextPos.x;
				spr.y = nextPos.y;


				var end = getEnding( spr.room, spr.x, spr.y );
				var ext = getExit( spr.room, spr.x, spr.y );
				var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
				if (end) { //if the sprite hits an ending
					if (id === playerId) { // only the player can end the game
						startNarrating( ending[end.id], true /*isEnding*/ );
					}
				}
				else if (ext) { //if the sprite hits an exit
					//move it to another scene
					spr.room = ext.dest.room;
					spr.x = ext.dest.x;
					spr.y = ext.dest.y;
					if (id === playerId) {
						//if the player changes scenes, change the visible scene
						curRoom = ext.dest.room;
					}
				}
				else if(itmIndex > -1) {
					var itm = room[ spr.room ].items[ itmIndex ];
					room[ spr.room ].items.splice( itmIndex, 1 );
					if( spr.inventory[ itm.id ] )
						spr.inventory[ itm.id ] += 1;
					else
						spr.inventory[ itm.id ] = 1;

					if(onInventoryChanged != null)
						onInventoryChanged( itm.id );

					if(id === playerId)
						startItemDialog( itm.id  /*itemId*/ );

					// stop moving : is this a good idea?
					spr.walkingPath = [];
				}

				if (id === playerId) didPlayerMoveThisFrame = true;
			}
		}

		moveCounter = 0;
	}

}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : Direction.None,
			tapReleased : false
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = Direction.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == Direction.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = Direction.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == Direction.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == Direction.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == Direction.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == Direction.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

function movePlayer(direction) {
	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
		didPlayerMoveThisFrame = true;
	}

	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	// TODO : vNext
	// var eff = getEffect( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		// TODO pick up items (what about touch?)
		// console.log("HIT ITM ");
		// console.log( itmIndex );
		var itm = room[ player().room ].items[ itmIndex ];
		// console.log(itm);
		room[ player().room ].items.splice( itmIndex, 1 );
		if( player().inventory[ itm.id ] )
			player().inventory[ itm.id ] += 1;
		else
			player().inventory[ itm.id ] = 1;

		if(onInventoryChanged != null)
			onInventoryChanged( itm.id );

		startItemDialog( itm.id  /*itemId*/ );

		// console.log( player().inventory );
	}

	if (end) {
		startNarrating( ending[end.id], true /*isEnding*/ );
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	// TODO : vNext
	// else if (eff) {
	// 	startDialog( script[eff.id].source, eff.id );
	// }
	else if (spr) {
		startSpriteDialog( spr /*spriteId*/ );
	}
}

var transition = new TransitionManager();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(player().room, player().x, player().y, ext.dest.room, ext.dest.x, ext.dest.y, ext.transition_effect);
			transition.UpdateTransition(0);
		}

		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;
	};

	// TODO : vNext
	// if(ext.script_id != null && script[ext.script_id]){
	// 	var scriptSourceStr = script[ext.script_id].source;
	// 	startDialog(scriptSourceStr, ext.script_id, function(isExitUnlocked) {
	// 		if (isExitUnlocked == true) {
	// 			GoToDest();
	// 		}
	// 	});
	// }
	// else {
	// 	GoToDest();
	// }

	GoToDest();
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

// TODO : vNext
// function getEffect(roomId,x,y) {
// 	for (i in room[roomId].effects) {
// 		var e = room[roomId].effects[i];
// 		if (x == e.x && y == e.y) {
// 			return e;
// 		}
// 	}
// 	return null;
// }

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	// console.log("~~~ PARSE WORLD ~~~");
	// console.log(file);

	// var parseTimer = new Timer();

	resetFlags();

	var versionNumber = 0;

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i);
		}
		else if (getType(curLine) === "END") {
			i = parseEnding(lines, i);
		}
		// TODO: vNext
		// else if (getType(curLine) === "PRG") {
		// 	i = parseScript(lines, i);
		// }
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}
	placeSprites();
	if (player().room != null) {
		curRoom = player().room;
	}

	renderer.SetPalettes(palette);

	// console.log(names);

	// console.log("~~~~~ PARSE TIME " + parseTimer.Milliseconds());

	return versionNumber;
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += title + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		worldStr += "PAL " + id + "\n";
		if( palette[id].name != null )
			worldStr += "NAME " + palette[id].name + "\n";
		for (i in getPal(id)) {
			for (j in getPal(id)[i]) {
				worldStr += getPal(id)[i][j];
				if (j < 2) worldStr += ",";
			}
			worldStr += "\n";
		}
		worldStr += "\n";
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					// TODO : vNext
					// if (e.script_id != undefined && e.script_id != null) {
					// 	worldStr += " PRG " + e.script_id;
					// }
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		// TODO : vNext
		// if (room[id].effects.length > 0) {
		// 	/* EFFECTS */
		// 	for (j in room[id].effects) {
		// 		var e = room[id].effects[j];
		// 		worldStr += "EFF " + e.id + " " + e.x + "," + e.y;
		// 		worldStr += "\n";
		// 	}
		// }
		if (room[id].pal != null) {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		worldStr += "DLG " + id + "\n";
		worldStr += dialog[id] + "\n";
		worldStr += "\n";
	}
	/* ENDINGS */
	for (id in ending) {
		worldStr += "END " + id + "\n";
		worldStr += ending[id] + "\n";
		worldStr += "\n";
	}
	// TODO : vNext
	// /* SCRIPTS */
	// for (id in script) {
	// 	if (script[id].type == ScriptType.Dialogue) {
	// 		worldStr += "DLG " + id + "\n";
	// 	}
	// 	else if (script[id].type == ScriptType.Ending) {
	// 		worldStr += "END " + id + "\n";
	// 	}
	// 	else {
	// 		worldStr += "PRG " + id + "\n";
	// 	}
	// 	worldStr += script[id].source + "\n";
	// 	worldStr += "\n";
	// }
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetImageSource(drwId);
	var drwStr = "";
	for (f in imageSource) {
		for (y in imageSource[f]) {
			var rowStr = "";
			for (x in imageSource[f][y]) {
				rowStr += imageSource[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageSource.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	title = lines[i];
	i++;
	return i;
}

function parseRoom(lines, i) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		// effects : [], // TODO vNext
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				// TODO : vNext
				// script_id : null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				// TODO : vNext
				// else if (exitArgs[exitArgIndex] == "PRG") {
				// 	ext.script_id = exitArgs[exitArgIndex+1];
				// 	exitArgIndex += 2;
				// }
				else {
					exitArgIndex += 1;
				}
			}

			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId( lines[i] );
			var endCoords = getCoord( lines[i], 2 );
			var end = {
				id : endId,
				x : parseInt( endCoords[0] ),
				y : parseInt( endCoords[1] )
			};
			room[id].endings.push(end);
		}
		// TODO : vNext
		// else if (getType(lines[i]) === "EFF") {
		// 	/* ADD EFFECT */
		// 	var effectId = getId( lines[i] );
		// 	var effectCoords = getCoord( lines[i], 2 );
		// 	var effect = {
		// 		id : effectId,
		// 		x : parseInt( effectCoords[0] ),
		// 		y : parseInt( effectCoords[1] ),
		// 	};
		// 	room[id].effects.push(effect);
		// }
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set( name, id);
		}
		i++;
	}
	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if(args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; // default palette color index is 1
	var isWall = null; // null indicates it can vary from room to room (original version)
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg( lines[i], 1 );
			if( wallArg === "true" ) {
				isWall = true;
			}
			else if( wallArg === "false" ) {
				isWall = false;
			}
		}
		i++;
	}

	//tile data
	tile[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name,
		isWall : isWall
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		walkingPath : [], //tile by tile movement path (isn't saved)
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetImageSource(drwId, frameList);

	return i;
}

// TODO : vNext
// var ScriptType = {
// 	Script : 0,
// 	Dialogue : 1, // TODO : move everything to this spelling?
// 	Ending : 2,
// };

function parseScript(lines, i, objectStore) {
	// TODO : vNext
	// if (scriptType === undefined || scriptType === null) {
	// 	scriptType = ScriptType.Script;
	// }

	var id = getId(lines[i]);
	i++;

	var results = scriptUtils.ReadDialogScript(lines,i);

	// TODO : vNext
	// script[id] = {
	// 	source: results.script,
	// 	type: scriptType,
	// };

	objectStore[id] = results.script;

	i = results.index;

	return i;
}

function parseDialog(lines, i) {
	return parseScript(lines, i, dialog);
}

function parseEnding(lines, i) {
	return parseScript(lines, i, ending);
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	context.putImageData(img,x*tilesize*scale,y*tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

// var debugLastRoomDrawn = "0";

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
	if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
		context = ctx;
	}

	// if (room.id != debugLastRoomDrawn) {
	// 	debugLastRoomDrawn = room.id;
	// 	console.log("DRAW ROOM " + debugLastRoomDrawn);
	// }

	//clear screen
	context.fillStyle = "rgb(" + getPal(room.pal)[0][0] + "," + getPal(room.pal)[0][1] + "," + getPal(room.pal)[0][2] + ")";
	context.fillRect(0,0,canvas.width,canvas.height);

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],getRoomPal(room.id),frameIndex), j, i, context );
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],getRoomPal(room.id),frameIndex), itm.x, itm.y, context );
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,getRoomPal(room.id),frameIndex), spr.x, spr.y, context );
		}
	}
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
	return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
	return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
	return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return "0";
		}
	}
	return "0";
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	if (isNarrating) isNarrating = false;
	if (isDialogPreview) {
		isDialogPreview = false;
		if (onDialogPreviewEnd != null)
			onDialogPreviewEnd();
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) end = false;

	isNarrating = true;
	isEnding = end;
	startDialog(dialogStr);
}

function startItemDialog(itemId) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg ? spr.dlg : spriteId;
	// console.log("START SPRITE DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr,scriptId,dialogCallback) {
	// console.log("START DIALOG ");
	if(dialogStr.length <= 0) {
		// console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog(dialogCallback);
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( isNarrating /*centered*/ );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if(scriptId === undefined) {
		scriptInterpreter.Interpret( dialogStr, onScriptEnd );
	}
	else {
		if( !scriptInterpreter.HasScript(scriptId) ) {
			scriptInterpreter.Compile( scriptId, dialogStr );
		}
		scriptInterpreter.DebugVisualizeScriptTree(scriptId);
		scriptInterpreter.Run( scriptId, onScriptEnd );
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, onScriptEnd) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( true );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	onDialogPreviewEnd = onScriptEnd;

	scriptInterpreter.Eval( script, null );
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
</script>

<!-- store default font in separate script tag for back compat-->
<script type="bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 1
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 2
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 3
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 4
000000
000000
001010
001110
001110
000100
000000
000000
CHAR 5
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 6
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 7
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 10
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 11
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 12
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 13
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 14
000011
001101
001011
001101
001011
011011
011000
000000
CHAR 15
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 16
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 17
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 18
000100
001110
011111
000100
011111
001110
000100
000000
CHAR 19
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 20
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 21
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 22
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 23
000100
001110
011111
000100
011111
001110
000100
001110
CHAR 24
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 25
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 26
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 27
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 28
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 29
000000
001010
001010
011111
001010
001010
000000
000000
CHAR 30
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 31
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
001010
010100
000000
000000
000000
000000
000000
000000
CHAR 127
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 128
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 129
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 130
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 131
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 132
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 133
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 134
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 135
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 136
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 137
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 138
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 139
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 140
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 141
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 142
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 143
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 144
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 145
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 146
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 147
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 148
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 149
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 150
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 151
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 152
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 153
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 154
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 155
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 156
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 157
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 158
011000
010100
010100
011010
010111
010010
010010
000000
CHAR 159
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 160
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 161
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 162
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 163
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 164
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 165
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 166
001110
000001
001111
010001
001111
000000
001111
000000
CHAR 167
001100
010010
010010
010010
001100
000000
011110
000000
CHAR 168
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 169
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 170
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 171
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 172
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 173
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 174
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 175
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 176
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 177
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 178
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 179
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 180
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 183
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 184
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 185
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 186
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 187
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 188
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 189
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 190
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 191
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 192
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 193
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 194
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 195
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 196
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 197
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 198
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 199
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 200
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 201
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 202
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 203
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 204
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 205
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 206
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 207
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 208
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 209
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 210
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 211
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 212
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 213
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 214
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 215
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 216
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 217
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 218
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 219
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 220
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 221
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 222
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 223
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 224
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 225
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 226
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 227
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 230
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 231
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 232
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 233
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 234
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 235
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 236
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 237
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 238
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 239
000000
001100
010010
010010
010010
010010
000000
000000
CHAR 240
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 241
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 242
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 243
000000
000000
111111
111000
100110
100001
100000
111111
CHAR 244
000000
000000
111111
000111
011001
100001
000001
111111
CHAR 245
000100
000100
000100
000100
000100
010100
001000
000000
CHAR 246
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 247
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 248
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 249
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 250
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 251
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 252
001010
000000
010010
010010
010010
010110
001010
000000
CHAR 253
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 254
000000
000000
000000
011110
110010
110011
111110
001111
CHAR 255
010010
111111
010010
010010
111111
010010
000000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body style='background-color:black' onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>
